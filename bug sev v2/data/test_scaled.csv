project_name,project_version,label,code,code_comment,code_no_comment,lc,pi,ma,nbd,ml,d,mi,fo,r,e
Cli,1.0,1.0,"/**
 * Returns an iterator over the Option members of CommandLine.
 *
 * @return an <code>Iterator</code> over the processed {@link Option}
 * members of this {@link CommandLine}
 */
public Iterator iterator() {
    return hashcodeMap.values().iterator();
}","/**
 * Returns an iterator over the Option members of CommandLine.
 *
 * @return an <code>Iterator</code> over the processed {@link Option}
 * members of this {@link CommandLine}
 */
","public Iterator iterator() {
    return hashcodeMap.values().iterator();
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9284961966062023,-0.3333333333333333,0.8375,0.0
Cli,10.0,3.0,"protected void setOptions(final Options options) {
    this.options = options;
    this.requiredOptions = options.getRequiredOptions();
}","/**
 * {@inheritDoc}
 */
","protected void setOptions(final Options options) {
    this.options = options;
    this.requiredOptions = options.getRequiredOptions();
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.5170275014628429,-0.6666666666666666,-0.04999999999999998,0.0
Cli,21.0,1.0,"/**
 * Helper method for testing whether an element of the command line looks
 * like an option. This method queries the command line, but sets the
 * current option first.
 *
 * @param commandLine the command line
 * @param trigger the trigger to be checked
 * @return a flag whether this element looks like an option
 */
private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) {
    return commandLine.looksLikeOption(trigger);
}","/**
 * Helper method for testing whether an element of the command line looks
 * like an option. This method queries the command line, but sets the
 * current option first.
 *
 * @param commandLine the command line
 * @param trigger the trigger to be checked
 * @return a flag whether this element looks like an option
 */
","private boolean looksLikeOption(final WriteableCommandLine commandLine, final String trigger) {
    return commandLine.looksLikeOption(trigger);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8039789350497368,-0.6666666666666666,0.7999999999999999,0.0
Cli,22.0,1.0,"/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * add the token to the processed list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then add the remaining tokens to the processed tokens list
 * directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }
    tokens.add(token);
}","/**
 * <p>If an {@link Option} exists for <code>token</code> then
 * add the token to the processed list.</p>
 *
 * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>
 * is set then add the remaining tokens to the processed tokens list
 * directly.</p>
 *
 * @param token The current option token
 * @param stopAtNonOption Specifies whether flattening should halt
 * at the first non option.
 */
","private void processOptionToken(String token, boolean stopAtNonOption) {
    if (stopAtNonOption && !options.hasOption(token)) {
        eatTheRest = true;
    }
    tokens.add(token);
}",0.0,0.5896226415094338,0.0,0.0,1.6666666666666667,0.8758620689655173,0.018490345231129118,-0.3333333333333333,0.18749999999999997,0.5895761392710812
Cli,27.0,1.0,"/**
 * Set the selected option of this group to <code>name</code>.
 *
 * @param option the option that is selected
 * @throws AlreadySelectedException if an option from this group has
 * already been selected.
 */
public void setSelected(Option option) throws AlreadySelectedException {
    if (option == null) {
        // reset the option previously selected
        selected = null;
        return;
    }
    // selected member variable
    if (selected == null || selected.equals(option.getOpt())) {
        selected = option.getOpt();
    } else {
        throw new AlreadySelectedException(this, option);
    }
}","/**
 * Set the selected option of this group to <code>name</code>.
 *
 * @param option the option that is selected
 * @throws AlreadySelectedException if an option from this group has
 * already been selected.
 */
","public void setSelected(Option option) throws AlreadySelectedException {
    if (option == null) {
                selected = null;
        return;
    }
        if (selected == null || selected.equals(option.getOpt())) {
        selected = option.getOpt();
    } else {
        throw new AlreadySelectedException(this, option);
    }
}",0.8333333333333334,0.693396226415094,1.0,0.0,2.3333333333333335,1.5310344827586209,-0.5418373317729664,0.0,-0.28750000000000003,1.4253457622873094
Closure,3.0,1.0,"@Override
public boolean apply(Node input) {
    switch(input.getType()) {
        case Token.GETELEM:
        case Token.GETPROP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
        case Token.REGEXP:
        case Token.NEW:
            return true;
    }
    return false;
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean apply(Node input) {
    switch(input.getType()) {
        case Token.GETELEM:
        case Token.GETPROP:
        case Token.ARRAYLIT:
        case Token.OBJECTLIT:
        case Token.REGEXP:
        case Token.NEW:
            return true;
    }
    return false;
}",1.1666666666666667,1.4764150943396221,2.5,1.0,2.3333333333333335,0.0,-0.6794616734932706,-0.6666666666666666,-0.3375000000000001,0.0
Closure,9.0,2.0,"private String normalizeSourceName(String filename) {
    if (filename.indexOf(filenamePrefix) == 0) {
        filename = filename.substring(filenamePrefix.length());
    }
    return filename;
}","/**
 * {@inheritDoc}
 */
","private String normalizeSourceName(String filename) {
    if (filename.indexOf(filenamePrefix) == 0) {
        filename = filename.substring(filenamePrefix.length());
    }
    return filename;
}",0.0,0.5896226415094338,0.0,0.0,1.0,1.1517241379310346,0.041895845523697864,0.0,-0.225,0.701508292927305
Closure,13.0,2.0,"private void traverse(Node node) {
    // and revisit immediately.
    if (!shouldVisit(node)) {
        return;
    }
    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            Node next = c.getNext();
            c = next;
        }
        visit(node);
        visits++;
        Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));
    exitNode(node);
}","/**
 * {@inheritDoc}
 */
","private void traverse(Node node) {
        if (!shouldVisit(node)) {
        return;
    }
    int visits = 0;
    do {
        Node c = node.getFirstChild();
        while (c != null) {
            traverse(c);
            Node next = c.getNext();
            c = next;
        }
        visit(node);
        visits++;
        Preconditions.checkState(visits < 10000, ""too many interations"");
    } while (shouldRetraverse(node));
    exitNode(node);
}",2.0,1.35377358490566,1.0,1.0,2.3333333333333335,2.4689655172413794,-1.1016968987712106,1.6666666666666667,-0.3,4.932386251811563
Closure,19.0,2.0,"/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */
protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}","/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */
","protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}",1.6666666666666667,2.0424528301886786,3.0,1.0,1.6666666666666667,1.1310344827586207,-1.1213575190169682,2.0,-0.4,2.9707108479003774
Closure,26.0,2.0,"/**
 * Emit <code>if (moduleName.module$exports) {
 *    moduleName = moduleName.module$export;
 * }</code> at end of file.
 */
private void emitOptionalModuleExportsOverride(Node script, String moduleName) {
    Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(""module$exports""));
    script.addChildToBack(IR.ifNode(moduleExportsProp, IR.block(IR.exprResult(IR.assign(IR.name(moduleName), moduleExportsProp.cloneTree())))).copyInformationFromForTree(script));
}","/**
 * Emit <code>if (moduleName.module$exports) {
 *    moduleName = moduleName.module$export;
 * }</code> at end of file.
 */
","private void emitOptionalModuleExportsOverride(Node script, String moduleName) {
    Node moduleExportsProp = IR.getprop(IR.name(moduleName), IR.string(""module$exports""));
    script.addChildToBack(IR.ifNode(moduleExportsProp, IR.block(IR.exprResult(IR.assign(IR.name(moduleName), moduleExportsProp.cloneTree())))).copyInformationFromForTree(script));
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.12990052662375612,2.6666666666666665,-0.3875,0.0
Closure,34.0,2.0,"/**
 * We could use addList recursively here, but sometimes we produce
 * very deeply nested operators and run out of stack space, so we
 * just unroll the recursion when possible.
 *
 * We assume nodes are left-recursive.
 */
private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator.getType() == op) {
        firstNonOperator = firstNonOperator.getFirstChild();
    }
    addExpr(firstNonOperator, leftPrecedence, context);
    Node current = firstNonOperator;
    do {
        current = current.getParent();
        cc.listSeparator();
        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
    } while (current != n);
}","/**
 * We could use addList recursively here, but sometimes we produce
 * very deeply nested operators and run out of stack space, so we
 * just unroll the recursion when possible.
 *
 * We assume nodes are left-recursive.
 */
","private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator.getType() == op) {
        firstNonOperator = firstNonOperator.getFirstChild();
    }
    addExpr(firstNonOperator, leftPrecedence, context);
    Node current = firstNonOperator;
    do {
        current = current.getParent();
        cc.listSeparator();
        addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
    } while (current != n);
}",1.1666666666666667,0.4952830188679243,0.5,0.0,2.0,1.4137931034482758,-0.8816851960210649,2.0,-0.3875,3.2922653021058848
Closure,34.0,2.0,"@Override
void appendOp(String op, boolean binOp) {
    if (binOp) {
        if (getLastChar() != ' ') {
            append("" "");
        }
        append(op);
        append("" "");
    } else {
        append(op);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
void appendOp(String op, boolean binOp) {
    if (binOp) {
        if (getLastChar() != ' ') {
            append("" "");
        }
        append(op);
        append("" "");
    } else {
        append(op);
    }
}",1.0,1.55188679245283,0.5,1.0,1.3333333333333333,0.0,-0.4987712112346399,0.6666666666666666,0.2750000000000001,0.0
Closure,44.0,2.0,"void add(String newcode) {
    maybeEndStatement();
    if (newcode.length() == 0) {
        return;
    }
    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
        // need space to separate. This is not pretty printing.
        // For example: ""return foo;""
        append("" "");
    // Do not allow a forward slash to appear after a DIV.
    // For example,
    // REGEXP DIV REGEXP
    // is valid and should print like
    // / // / /
    }
    append(newcode);
}","/**
 * {@inheritDoc}
 */
","void add(String newcode) {
    maybeEndStatement();
    if (newcode.length() == 0) {
        return;
    }
    char c = newcode.charAt(0);
    if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
                        append("" "");
                        }
    append(newcode);
}",0.8333333333333334,0.26886792452830194,0.5,0.0,3.0,2.1655172413793107,-0.5867758923346982,1.6666666666666667,0.7500000000000002,2.532429192535471
Closure,52.0,2.0,"static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return len > 0;
}","/**
 * {@inheritDoc}
 */
","static boolean isSimpleNumber(String s) {
    int len = s.length();
    for (int index = 0; index < len; index++) {
        char c = s.charAt(index);
        if (c < '0' || c > '9') {
            return false;
        }
    }
    return len > 0;
}",0.6666666666666666,1.3915094339622638,0.5,1.0,2.0,2.6413793103448278,-0.5507314218841425,-0.3333333333333333,-0.04999999999999998,3.588413161331878
Closure,55.0,2.0,"private static boolean isReduceableFunctionExpression(Node n) {
    return NodeUtil.isFunctionExpression(n);
}","/**
 * {@inheritDoc}
 */
","private static boolean isReduceableFunctionExpression(Node n) {
    return NodeUtil.isFunctionExpression(n);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8653013458162657,-0.6666666666666666,0.6625000000000001,0.0
Closure,79.0,1.0,"@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    // function f() {
    // try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    // var e = 1; // f scope 'e'
    // }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void process(Node externs, Node root) {
    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
                                                            removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);
    if (!compiler.getLifeCycleStage().isNormalized()) {
        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
}",1.3333333333333333,0.6462264150943395,0.5,0.0,1.0,1.2896551724137932,-0.9256875365710939,1.3333333333333333,-0.4,2.8582061512587003
Closure,85.0,1.0,"private Node computeFollowing(Node n) {
    Node next = ControlFlowAnalysis.computeFollowNode(n);
    return next;
}","/**
 * {@inheritDoc}
 */
","private Node computeFollowing(Node n) {
    Node next = ControlFlowAnalysis.computeFollowNode(n);
    return next;
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.4795787009947337,-0.6666666666666666,0.525,0.0
Closure,100.0,2.0,"private boolean shouldReportThis(Node n, Node parent) {
    if (assignLhsChild != null) {
        // Always report a THIS on the left side of an assign.
        return true;
    }
    // Also report a THIS with a property access.
    return false;
}","/**
 * {@inheritDoc}
 */
","private boolean shouldReportThis(Node n, Node parent) {
    if (assignLhsChild != null) {
                return true;
    }
        return false;
}",0.0,0.5896226415094338,0.0,0.0,0.6666666666666666,0.0,0.1575190169689874,-1.0,0.7749999999999999,0.0
Closure,101.0,2.0,"@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }
    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }
    if (flags.process_closure_primitives) {
        options.closurePass = true;
    }
    initOptionsFromFlags(options);
    return options;
}","/**
 * {@inheritDoc}
 */
","@Override
protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
        level.setDebugOptionsForCompilationLevel(options);
    }
    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
        formattingOption.applyToOptions(options);
    }
    if (flags.process_closure_primitives) {
        options.closurePass = true;
    }
    initOptionsFromFlags(options);
    return options;
}",2.3333333333333335,0.06132075471698106,1.0,0.0,1.3333333333333333,0.0,-1.2229373902867167,1.0,-0.4,0.0
Closure,102.0,2.0,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, this);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    removeDuplicateDeclarations(root);
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}","/**
 * {@inheritDoc}
 */
","@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, this);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    removeDuplicateDeclarations(root);
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}",0.8333333333333334,0.7783018867924528,0.0,0.0,0.3333333333333333,0.0,-0.6321825629022815,0.3333333333333333,-0.4,0.0
Closure,120.0,2.0,"/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
    // Make sure this assignment is not in a loop.
    for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
        if (block.isFunction) {
            break;
        } else if (block.isLoop) {
            return false;
        }
    }
    return true;
}","/**
 * @return Whether the variable is only assigned a value once for its
 *     lifetime.
 */
","boolean isAssignedOnceInLifetime() {
    Reference ref = getOneAndOnlyAssignment();
    if (ref == null) {
        return false;
    }
        for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {
        if (block.isFunction) {
            break;
        } else if (block.isLoop) {
            return false;
        }
    }
    return true;
}",1.3333333333333333,1.4009433962264146,2.0,2.0,2.6666666666666665,1.1310344827586207,-0.805851375073142,0.0,0.08750000000000002,1.3456191515628635
Closure,129.0,2.0,"/**
 * There are two types of calls we are interested in calls without explicit
 * ""this"" values (what we are call ""free"" calls) and direct call to eval.
 */
private void annotateCalls(Node n) {
    Preconditions.checkState(n.isCall());
    // Keep track of of the ""this"" context of a call.  A call without an
    // explicit ""this"" is a free call.
    Node first = n.getFirstChild();
    if (!NodeUtil.isGet(first)) {
        n.putBooleanProp(Node.FREE_CALL, true);
    }
    // to distinguish between ""(0, eval)()"" and ""eval()"".
    if (first.isName() && ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
    }
}","/**
 * There are two types of calls we are interested in calls without explicit
 * ""this"" values (what we are call ""free"" calls) and direct call to eval.
 */
","private void annotateCalls(Node n) {
    Preconditions.checkState(n.isCall());
            Node first = n.getFirstChild();
    if (!NodeUtil.isGet(first)) {
        n.putBooleanProp(Node.FREE_CALL, true);
    }
        if (first.isName() && ""eval"".equals(first.getString())) {
        first.putBooleanProp(Node.DIRECT_EVAL, true);
    }
}",0.6666666666666666,0.3820754716981129,0.5,0.0,2.6666666666666665,1.1241379310344828,-0.5867758923346982,2.0,-0.25000000000000006,1.7704460467696053
Closure,134.0,2.0,"/**
 * Returns true if prop is in an independent set from all properties in
 * this sub graph.  That is, if none of its types is contained in the
 * related types for this sub graph and if none if its related types is one
 * of the types in the sub graph.
 */
public boolean isIndependentOf(Property prop) {
    if (typesRelatedToSet.intersects(prop.typesSet)) {
        return false;
    }
    return !getRelated(prop.type).intersects(typesInSet);
}","/**
 * Returns true if prop is in an independent set from all properties in
 * this sub graph.  That is, if none of its types is contained in the
 * related types for this sub graph and if none if its related types is one
 * of the types in the sub graph.
 */
","public boolean isIndependentOf(Property prop) {
    if (typesRelatedToSet.intersects(prop.typesSet)) {
        return false;
    }
    return !getRelated(prop.type).intersects(typesInSet);
}",0.0,0.5896226415094338,0.0,0.0,1.0,0.0,0.06342890579286148,0.0,0.19999999999999998,0.0
Closure,137.0,2.0,"/**
 * Prepare a set for the new scope.
 */
private static String getNameSuffix(String name, int index) {
    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());
}","/**
 * Prepare a set for the new scope.
 */
","private static String getNameSuffix(String name, int index) {
    return name.substring(index + ContextualRenamer.UNIQUE_ID_SEPARATOR.length(), name.length());
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.618607372732592,0.0,0.33749999999999997,0.0
Closure,137.0,2.0,"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));
    removeDuplicateDeclarations(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    // function f() {
    // try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    // var e = 1; // f scope 'e'
    // }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}","/**
 * {@inheritDoc}
 */
","@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));
    removeDuplicateDeclarations(root);
    if (MAKE_LOCAL_NAMES_UNIQUE) {
        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
        NodeTraversal t = new NodeTraversal(compiler, renamer);
        t.traverseRoots(externs, root);
    }
                                                            new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);
}",0.8333333333333334,0.7783018867924528,0.0,0.0,0.3333333333333333,0.0,-0.6569923932124044,0.3333333333333333,-0.3875,0.0
Closure,153.0,2.0,"/**
 * Declares a variable.
 *
 * @param n The node corresponding to the variable name.
 * @param declaredType The variable's type, according to JSDoc
 */
private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {
    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {
        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);
    } else {
        scope.declare(name, n, declaredType, compiler.getInput(sourceName));
    }
}","/**
 * Declares a variable.
 *
 * @param n The node corresponding to the variable name.
 * @param declaredType The variable's type, according to JSDoc
 */
","private void declareVar(String name, Node n, Node parent, Node gramps, JSType declaredType, Node nodeWithLineNumber) {
    if (scope.isDeclared(name, false) || (scope.isLocal() && name.equals(ARGUMENTS))) {
        redeclarationHandler.onRedeclaration(scope, name, n, parent, gramps, nodeWithLineNumber);
    } else {
        scope.declare(name, n, declaredType, compiler.getInput(sourceName));
    }
}",0.16666666666666666,0.8443396226415092,0.0,0.0,2.3333333333333335,1.1724137931034482,-0.36114686951433583,1.0,-0.4,2.310568785672112
Closure,166.0,2.0,"@Override
public void matchConstraint(JSType constraint) {
    // We only want to match constraints on anonymous types.
    if (hasReferenceName()) {
        return;
    }
    // properties on this object.
    if (constraint.isRecordType()) {
        matchRecordTypeConstraint(constraint.toObjectType());
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void matchConstraint(JSType constraint) {
        if (hasReferenceName()) {
        return;
    }
        if (constraint.isRecordType()) {
        matchRecordTypeConstraint(constraint.toObjectType());
    }
}",0.5,0.7783018867924528,0.5,0.0,1.3333333333333333,0.0,-0.149093036863663,0.3333333333333333,0.525,0.0
Closure,167.0,2.0,"private FlowScope caseEquality(Node left, Node right, FlowScope blindScope, Function<TypePair, TypePair> merging) {
    // left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
        leftIsRefineable = true;
    } else {
        leftIsRefineable = false;
        leftType = left.getJSType();
    }
    // right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
        rightIsRefineable = true;
    } else {
        rightIsRefineable = false;
        rightType = right.getJSType();
    }
    // merged types
    TypePair merged = merging.apply(new TypePair(leftType, rightType));
    // creating new scope
    if (merged != null) {
        return maybeRestrictTwoNames(blindScope, left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB);
    }
    return blindScope;
}","/**
 * {@inheritDoc}
 */
","private FlowScope caseEquality(Node left, Node right, FlowScope blindScope, Function<TypePair, TypePair> merging) {
        JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
        leftIsRefineable = true;
    } else {
        leftIsRefineable = false;
        leftType = left.getJSType();
    }
        JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
        rightIsRefineable = true;
    } else {
        rightIsRefineable = false;
        rightType = right.getJSType();
    }
        TypePair merged = merging.apply(new TypePair(leftType, rightType));
        if (merged != null) {
        return maybeRestrictTwoNames(blindScope, left, leftIsRefineable, merged.typeA, right, rightIsRefineable, merged.typeB);
    }
    return blindScope;
}",2.8333333333333335,0.21226415094339626,1.0,0.0,2.0,1.7379310344827588,-1.4373317729666464,1.0,-0.4,6.431590059222415
Closure,167.0,2.0,"/**
 * @see maybeRestrictName
 */
private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {
    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;
    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;
    if (shouldRefineLeft || shouldRefineRight) {
        FlowScope informed = blindScope.createChildFlowScope();
        if (shouldRefineLeft) {
            declareNameInScope(informed, left, restrictedLeftType);
        }
        if (shouldRefineRight) {
            declareNameInScope(informed, right, restrictedRightType);
        }
        return informed;
    }
    return blindScope;
}","/**
 * @see maybeRestrictName
 */
","private FlowScope maybeRestrictTwoNames(FlowScope blindScope, Node left, boolean leftIsRefineable, JSType restrictedLeftType, Node right, boolean rightIsRefineable, JSType restrictedRightType) {
    boolean shouldRefineLeft = leftIsRefineable && restrictedLeftType != null;
    boolean shouldRefineRight = rightIsRefineable && restrictedRightType != null;
    if (shouldRefineLeft || shouldRefineRight) {
        FlowScope informed = blindScope.createChildFlowScope();
        if (shouldRefineLeft) {
            declareNameInScope(informed, left, restrictedLeftType);
        }
        if (shouldRefineRight) {
            declareNameInScope(informed, right, restrictedRightType);
        }
        return informed;
    }
    return blindScope;
}",1.5,1.3349056603773581,1.0,1.0,2.0,3.144827586206896,-0.9940315974253944,0.0,-0.4,7.1241523680020045
Closure,169.0,2.0,"/**
 * Checks if two types are invariant.
 * @see EquivalenceMethod
 */
public final boolean isInvariant(JSType that) {
    return checkEquivalenceHelper(that, false);
}","/**
 * Checks if two types are invariant.
 * @see EquivalenceMethod
 */
","public final boolean isInvariant(JSType that) {
    return checkEquivalenceHelper(that, false);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8653013458162657,-0.6666666666666666,0.85,0.0
Closure,169.0,2.0,"/**
 * Two union types are equal if they have the same number of alternates
 * and all alternates are equal.
 */
boolean checkUnionEquivalenceHelper(UnionType that, boolean tolerateUnknowns) {
    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {
        return false;
    }
    for (JSType alternate : that.alternates) {
        if (!hasAlternate(alternate, tolerateUnknowns)) {
            return false;
        }
    }
    return true;
}","/**
 * Two union types are equal if they have the same number of alternates
 * and all alternates are equal.
 */
","boolean checkUnionEquivalenceHelper(UnionType that, boolean tolerateUnknowns) {
    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {
        return false;
    }
    for (JSType alternate : that.alternates) {
        if (!hasAlternate(alternate, tolerateUnknowns)) {
            return false;
        }
    }
    return true;
}",0.8333333333333334,1.2499999999999998,1.0,1.0,2.6666666666666665,1.206896551724138,-0.5629022820362785,0.0,-0.12500000000000003,1.2233096562952892
Codec,7.0,1.0,"/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */
public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}","/**
 * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.
 *
 * @param binaryData
 *            binary data to encode
 * @return String containing Base64 characters.
 * @since 1.4
 */
","public static String encodeBase64String(byte[] binaryData) {
    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7674663545933295,-0.3333333333333333,0.8375,0.0
Codec,17.0,1.0,"/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */
public static String newStringIso8859_1(final byte[] bytes) {
    return new String(bytes, Charsets.ISO_8859_1);
}","/**
 * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.
 *
 * @param bytes
 *            The bytes to be decoded into characters, may be <code>null</code>
 * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or
 *         <code>null</code> if the input byte array was <code>null</code>.
 * @throws NullPointerException
 *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is
 *             required by the Java platform specification.
 * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException
 */
","public static String newStringIso8859_1(final byte[] bytes) {
    return new String(bytes, Charsets.ISO_8859_1);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.83253364540667,-1.0,-0.375,0.0
Collections,25.0,1.0,"// Collated
// -----------------------------------------------------------------------
/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of ordered {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code>.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterator1  the first iterators to use, not null
 * @param iterator2  the first iterators to use, not null
 * @return a combination iterator over the iterators
 * @throws NullPointerException if either iterator is null
 */
public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {
    return new CollatingIterator<E>(comparator, iterator1, iterator2);
}","/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of ordered {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code>.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterator1  the first iterators to use, not null
 * @param iterator2  the first iterators to use, not null
 * @return a combination iterator over the iterators
 * @throws NullPointerException if either iterator is null
 */
","public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {
    return new CollatingIterator<E>(comparator, iterator1, iterator2);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.5722644821533055,-1.0,-0.225,0.0
Collections,25.0,1.0,"/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code> and so on.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterators  the iterators to use, not null or empty or contain nulls
 * @return a combination iterator over the iterators
 * @throws NullPointerException if iterators collection is null or contains a null
 * @throws ClassCastException if the iterators collection contains the wrong object type
 */
public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {
    return new CollatingIterator<E>(comparator, iterators);
}","/**
 * Gets an iterator that provides an ordered iteration over the elements
 * contained in a collection of {@link Iterator}s.
 * <p>
 * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,
 * the {@link Iterator#next()} method will return the lesser of
 * <code>A.next()</code> and <code>B.next()</code> and so on.
 * <p>
 * The comparator is optional. If null is specified then natural order is used.
 *
 * @param <E>  the element type
 * @param comparator  the comparator to use, may be null for natural order
 * @param iterators  the iterators to use, not null or empty or contain nulls
 * @return a combination iterator over the iterators
 * @throws NullPointerException if iterators collection is null or contains a null
 * @throws ClassCastException if the iterators collection contains the wrong object type
 */
","public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Collection<Iterator<? extends E>> iterators) {
    return new CollatingIterator<E>(comparator, iterators);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.6143943826799294,-1.0,-0.375,0.0
Compress,2.0,1.0,"public int read() throws IOException {
    final int ret = input.read();
    offset += (ret > 0 ? 1 : 0);
    return ret;
}","/**
 * {@inheritDoc}
 */
","public int read() throws IOException {
    final int ret = input.read();
    offset += (ret > 0 ? 1 : 0);
    return ret;
}",-0.16666666666666666,-0.15566037735849056,0.0,-1.0,0.6666666666666666,1.0344827586206897,0.2104154476301932,-0.6666666666666666,0.3625,0.5570843248465764
Compress,7.0,1.0,"/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */
public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        if (buffer[i] == 0) {
            break;
        }
        result.append((char) buffer[i]);
    }
    return result.toString();
}","/**
 * Parse an entry name from a buffer.
 * Parsing stops when a NUL is found
 * or the buffer length is reached.
 *
 * @param buffer The buffer from which to parse.
 * @param offset The offset into the buffer from which to parse.
 * @param length The maximum number of bytes to parse.
 * @return The entry name.
 */
","public static String parseName(byte[] buffer, final int offset, final int length) {
    StringBuffer result = new StringBuffer(length);
    int end = offset + length;
    for (int i = offset; i < end; ++i) {
        if (buffer[i] == 0) {
            break;
        }
        result.append((char) buffer[i]);
    }
    return result.toString();
}",0.8333333333333334,1.2499999999999998,1.0,1.0,1.3333333333333333,2.8620689655172415,-0.653715623171445,-0.3333333333333333,-0.1125,4.214775187418367
Compress,36.0,3.0,"private InputStream getCurrentStream() throws IOException {
    if (deferredBlockStreams.isEmpty()) {
        throw new IllegalStateException(""No current 7z entry (call getNextEntry() first)."");
    }
    while (deferredBlockStreams.size() > 1) {
        // In solid compression mode we need to decompress all leading folder'
        // streams to get access to an entry. We defer this until really needed
        // so that entire blocks can be skipped without wasting time for decompression.
        final InputStream stream = deferredBlockStreams.remove(0);
        IOUtils.skip(stream, Long.MAX_VALUE);
        stream.close();
    }
    return deferredBlockStreams.get(0);
}","/**
 * {@inheritDoc}
 */
","private InputStream getCurrentStream() throws IOException {
    if (deferredBlockStreams.isEmpty()) {
        throw new IllegalStateException(""No current 7z entry (call getNextEntry() first)."");
    }
    while (deferredBlockStreams.size() > 1) {
                                final InputStream stream = deferredBlockStreams.remove(0);
        IOUtils.skip(stream, Long.MAX_VALUE);
        stream.close();
    }
    return deferredBlockStreams.get(0);
}",0.8333333333333334,0.693396226415094,1.0,0.0,1.3333333333333333,0.9448275862068967,-0.6190754827384436,1.0,-0.375,1.2044873056484946
Compress,38.0,1.0,"/**
 * Return whether or not this entry represents a directory.
 *
 * @return True if this entry is a directory.
 */
@Override
public boolean isDirectory() {
    if (file != null) {
        return file.isDirectory();
    }
    if (linkFlag == LF_DIR) {
        return true;
    }
    if (getName().endsWith(""/"")) {
        return true;
    }
    return false;
}","/**
 * Return whether or not this entry represents a directory.
 *
 * @return True if this entry is a directory.
 */
","@Override
public boolean isDirectory() {
    if (file != null) {
        return file.isDirectory();
    }
    if (linkFlag == LF_DIR) {
        return true;
    }
    if (getName().endsWith(""/"")) {
        return true;
    }
    return false;
}",1.1666666666666667,0.5613207547169812,1.0,0.0,2.0,0.8620689655172414,-0.5895845523698066,0.0,0.5625000000000001,0.5790556619133671
Compress,47.0,1.0,"/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */
@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}","/**
 * Whether this class is able to read the given entry.
 *
 * <p>May return false if it is set up to use encryption or a
 * compression method that hasn't been implemented yet.</p>
 * @since 1.1
 */
","@Override
public boolean canReadEntryData(final ArchiveEntry ae) {
    if (ae instanceof ZipArchiveEntry) {
        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);
    }
    return false;
}",0.3333333333333333,0.9386792452830187,0.0,0.0,0.6666666666666666,1.0689655172413794,-0.21977764774722083,-0.3333333333333333,0.7875,0.7776565099926643
Csv,5.0,1.0,"/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */
public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    out.append(recordSeparator);
    newRecord = true;
}","/**
 * Outputs the record separator.
 *
 * @throws IOException
 *             If an I/O error occurs
 */
","public void println() throws IOException {
    final String recordSeparator = format.getRecordSeparator();
    out.append(recordSeparator);
    newRecord = true;
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.2291398478642478,-0.3333333333333333,0.8375,0.0
JxPath,3.0,1.0,"public NodePointer createPath(JXPathContext context, Object value) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        NodePointer pointer = newParent.createAttribute(context, getName());
        pointer.setValue(value);
        return pointer;
    } else {
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), index, value);
    }
}","/**
 * {@inheritDoc}
 */
","public NodePointer createPath(JXPathContext context, Object value) {
    NodePointer newParent = parent.createPath(context);
    if (isAttribute()) {
        NodePointer pointer = newParent.createAttribute(context, getName());
        pointer.setValue(value);
        return pointer;
    } else {
        if (newParent instanceof PropertyOwnerPointer) {
            PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
            newParent = pop.getPropertyPointer();
        }
        return newParent.createChild(context, getName(), index, value);
    }
}",1.3333333333333333,1.4009433962264146,0.5,1.0,1.3333333333333333,0.0,-0.8858981860737267,1.6666666666666667,-0.4,0.0
JxPath,7.0,1.0,"public Object computeValue(EvalContext context) {
    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));
    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));
    return l > r ? Boolean.TRUE : Boolean.FALSE;
}","/**
 * {@inheritDoc}
 */
","public Object computeValue(EvalContext context) {
    double l = InfoSetUtil.doubleValue(args[0].computeValue(context));
    double r = InfoSetUtil.doubleValue(args[1].computeValue(context));
    return l > r ? Boolean.TRUE : Boolean.FALSE;
}",-0.16666666666666666,-0.15566037735849056,0.0,-1.0,1.0,1.1517241379310346,0.018022235225277506,0.3333333333333333,-0.325,1.3651571809414755
Lang,13.0,1.0,"/**
 * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>
 * of the current <code>Thread</code> to resolve the class.
 * @param desc An instance of class <code>ObjectStreamClass</code>.
 * @return A <code>Class</code> object corresponding to <code>desc</code>.
 * @throws IOException Any of the usual Input/Output exceptions.
 * @throws ClassNotFoundException If class of a serialized object cannot be found.
 */
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
    String name = desc.getName();
    try {
        return Class.forName(name, false, classLoader);
    } catch (ClassNotFoundException ex) {
        return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
    }
}","/**
 * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>
 * of the current <code>Thread</code> to resolve the class.
 * @param desc An instance of class <code>ObjectStreamClass</code>.
 * @return A <code>Class</code> object corresponding to <code>desc</code>.
 * @throws IOException Any of the usual Input/Output exceptions.
 * @throws ClassNotFoundException If class of a serialized object cannot be found.
 */
","@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
    String name = desc.getName();
    try {
        return Class.forName(name, false, classLoader);
    } catch (ClassNotFoundException ex) {
        return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
    }
}",0.5,0.7783018867924528,0.0,0.0,0.0,0.0,-0.4280866003510821,0.6666666666666666,-0.4,0.0
Lang,30.0,3.0,"// IndexOfAny chars
// -----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                // ch is a supplementary character
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
","public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}",1.6666666666666667,1.9952830188679243,1.5,2.0,4.666666666666667,3.103448275862069,-1.0399063779988293,0.3333333333333333,-0.3125,6.6485122828362355
Lang,31.0,3.0,"// ContainsAny
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                // ch is in the Basic Multilingual Plane
                return true;
            }
        }
    }
    return false;
}","/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
","public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                                return true;
            }
        }
    }
    return false;
}",1.6666666666666667,1.9952830188679243,1.5,2.0,4.666666666666667,2.924137931034483,-1.0436512580456403,0.3333333333333333,-0.3875,6.353008534468878
Lang,32.0,1.0,"@Override
protected Set<IDKey> initialValue() {
    return new HashSet<IDKey>();
}","/**
 * {@inheritDoc}
 */
","@Override
protected Set<IDKey> initialValue() {
    return new HashSet<IDKey>();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.6466939730836743,-1.0,0.26250000000000007,0.0
Lang,41.0,3.0,"/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */
public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Handle array encoding
    // Strip Object type encoding
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */
","public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
            int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}",1.5,0.15566037735849056,1.5,0.0,2.6666666666666665,2.9793103448275864,-1.0305441778818016,0.6666666666666666,-0.26250000000000007,7.5056806999338
Lang,41.0,3.0,"/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */
public static String getPackageName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    // Strip Object type encoding
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */
","public static String getPackageName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
            int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}",0.6666666666666666,0.3820754716981129,0.5,0.0,1.3333333333333333,1.1172413793103448,-0.48566413107080136,-0.3333333333333333,-0.075,1.1561074233776458
Lang,46.0,0.0,"/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules
 * to a <code>Writer</code>.</p>
 *
 * <p>A <code>null</code> string input has no effect.</p>
 *
 * @see #escapeJavaScript(java.lang.String)
 * @param out  Writer to write escaped string into
 * @param str  String to escape values in, may be null
 * @throws IllegalArgumentException if the Writer is <code>null</code>
 * @throws IOException if error occurs on underlying Writer
 */
public static void escapeJavaScript(Writer out, String str) throws IOException {
    escapeJavaStyleString(out, str, true);
}","/**
 * <p>Escapes the characters in a <code>String</code> using JavaScript String rules
 * to a <code>Writer</code>.</p>
 *
 * <p>A <code>null</code> string input has no effect.</p>
 *
 * @see #escapeJavaScript(java.lang.String)
 * @param out  Writer to write escaped string into
 * @param str  String to escape values in, may be null
 * @throws IllegalArgumentException if the Writer is <code>null</code>
 * @throws IOException if error occurs on underlying Writer
 */
","public static void escapeJavaScript(Writer out, String str) throws IOException {
    escapeJavaStyleString(out, str, true);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7052077238150961,-0.6666666666666666,0.06249999999999999,0.0
Math,11.0,0.0,"/**
 * {@inheritDoc}
 */
public double density(final double[] vals) throws DimensionMismatchException {
    final int dim = getDimension();
    if (vals.length != dim) {
        throw new DimensionMismatchException(vals.length, dim);
    }
    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);
}","/**
 * {@inheritDoc}
 */
","public double density(final double[] vals) throws DimensionMismatchException {
    final int dim = getDimension();
    if (vals.length != dim) {
        throw new DimensionMismatchException(vals.length, dim);
    }
    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals);
}",0.16666666666666666,0.410377358490566,0.5,0.0,1.0,2.5586206896551724,-0.2974839087185489,0.3333333333333333,0.10000000000000003,3.7263244529530692
Math,30.0,3.0,"/**
 * @param Umin smallest Mann-Whitney U value
 * @param n1 number of subjects in first sample
 * @param n2 number of subjects in second sample
 * @return two-sided asymptotic p-value
 * @throws ConvergenceException if the p-value can not be computed
 * due to a convergence error
 * @throws MaxCountExceededException if the maximum number of
 * iterations is exceeded
 */
private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException {
    final int n1n2prod = n1 * n2;
    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
    final double EU = n1n2prod / 2.0;
    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;
    final double z = (Umin - EU) / FastMath.sqrt(VarU);
    final NormalDistribution standardNormal = new NormalDistribution(0, 1);
    return 2 * standardNormal.cumulativeProbability(z);
}","/**
 * @param Umin smallest Mann-Whitney U value
 * @param n1 number of subjects in first sample
 * @param n2 number of subjects in second sample
 * @return two-sided asymptotic p-value
 * @throws ConvergenceException if the p-value can not be computed
 * due to a convergence error
 * @throws MaxCountExceededException if the maximum number of
 * iterations is exceeded
 */
","private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException {
    final int n1n2prod = n1 * n2;
        final double EU = n1n2prod / 2.0;
    final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;
    final double z = (Umin - EU) / FastMath.sqrt(VarU);
    final NormalDistribution standardNormal = new NormalDistribution(0, 1);
    return 2 * standardNormal.cumulativeProbability(z);
}",0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,2.2344827586206897,-0.4880046811000581,-0.3333333333333333,0.11249999999999998,5.119679375928146
Math,34.0,1.0,"/**
 * Returns an iterator over the unmodifiable list of chromosomes.
 * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
 *
 * @return chromosome iterator
 */
public Iterator<Chromosome> iterator() {
    return chromosomes.iterator();
}","/**
 * Returns an iterator over the unmodifiable list of chromosomes.
 * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>
 *
 * @return chromosome iterator
 */
","public Iterator<Chromosome> iterator() {
    return chromosomes.iterator();
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9284961966062023,-0.6666666666666666,0.8375,0.0
Math,37.0,3.0,"/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(a &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */
public Complex tanh() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(a &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */
","public Complex tanh() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}",0.5,0.13679245283018865,0.0,0.0,0.6666666666666666,2.1931034482758625,-0.4997074312463425,0.6666666666666666,-0.025000000000000026,3.494802383210177
Math,47.0,3.0,"/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */
public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */
","public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}",1.0,0.410377358490566,1.5,0.0,3.3333333333333335,2.4413793103448276,-0.6780573434757164,0.3333333333333333,-0.225,2.8982841602404683
Math,49.0,1.0,"/**
 * {@inheritDoc}
 */
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}","/**
 * {@inheritDoc}
 */
","public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = res.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    return res;
}",0.6666666666666666,0.3820754716981129,0.0,0.0,0.6666666666666666,1.186206896551724,-0.5685196021064945,2.3333333333333335,-0.325,1.8111681666100088
Math,55.0,1.0,"/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
    // compute cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}","/**
 * Compute the cross-product of two vectors.
 * @param v1 first vector
 * @param v2 second vector
 * @return the cross product v1 ^ v2 as a new Vector
 */
","public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
        return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,2.7586206896551726,0.37378583967232276,-1.0,-0.375,3.8990177309405807
Math,62.0,1.0,"/**
 * {@inheritDoc}
 */
public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    return optimize(f, goal, min, max, 0);
}","/**
 * {@inheritDoc}
 */
","public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max) throws FunctionEvaluationException {
    return optimize(f, goal, min, max, 0);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.5928613224107658,-0.6666666666666666,-0.03750000000000003,0.0
Math,63.0,3.0,"/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) equals(x, y, 1)}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 */
public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}","/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) equals(x, y, 1)}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 */
","public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,1.3793103448275863,0.6298420128730241,-0.3333333333333333,0.7749999999999999,0.6806104739582401
Math,93.0,3.0,"/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */
public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}","/**
 * Returns n!. Shorthand for <code>n</code> <a
 * href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the
 * product of the numbers <code>1,...,n</code>.
 * <p>
 * <Strong>Preconditions</strong>:
 * <ul>
 * <li> <code>n >= 0</code> (otherwise
 * <code>IllegalArgumentException</code> is thrown)</li>
 * <li> The result is small enough to fit into a <code>long</code>. The
 * largest value of <code>n</code> for which <code>n!</code> <
 * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>
 * an <code>ArithMeticException </code> is thrown.</li>
 * </ul>
 * </p>
 *
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be represented
 *         by a long integer.
 * @throws IllegalArgumentException if n < 0
 */
","public static long factorial(final int n) {
    long result = Math.round(factorialDouble(n));
    if (result == Long.MAX_VALUE) {
        throw new ArithmeticException(""factorial value is too large to fit in a long"");
    }
    return factorials[n];
}",0.16666666666666666,0.410377358490566,0.5,0.0,0.6666666666666666,0.8620689655172414,-0.1093036863662964,-0.3333333333333333,-0.4,0.5790556619133671
Math,97.0,3.0,"/**
 * Find a zero in the given interval.
 * <p>
 * Requires that the values of the function at the endpoints have opposite
 * signs. An <code>IllegalArgumentException</code> is thrown if this is not
 * the case.</p>
 *
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException if the maximum iteration count is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if min is not less than max or the
 * signs of the values of the function at the endpoints are not opposites
 */
public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifyInterval(min, max);
    double ret = Double.NaN;
    double yMin = f.value(min);
    double yMax = f.value(max);
    // Verify bracketing
    double sign = yMin * yMax;
    if (sign >= 0) {
        // neither value is close to zero and min and max do not bracket root.
        throw new IllegalArgumentException(""Function values at endpoints do not have different signs."" + ""  Endpoints: ["" + min + "","" + max + ""]"" + ""  Values: ["" + yMin + "","" + yMax + ""]"");
    } else {
        // solve using only the first endpoint as initial guess
        ret = solve(min, yMin, max, yMax, min, yMin);
    // either min or max is a root
    }
    return ret;
}","/**
 * Find a zero in the given interval.
 * <p>
 * Requires that the values of the function at the endpoints have opposite
 * signs. An <code>IllegalArgumentException</code> is thrown if this is not
 * the case.</p>
 *
 * @param min the lower bound for the interval.
 * @param max the upper bound for the interval.
 * @return the value where the function is zero
 * @throws MaxIterationsExceededException if the maximum iteration count is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating the
 * function
 * @throws IllegalArgumentException if min is not less than max or the
 * signs of the values of the function at the endpoints are not opposites
 */
","public double solve(double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    verifyInterval(min, max);
    double ret = Double.NaN;
    double yMin = f.value(min);
    double yMax = f.value(max);
        double sign = yMin * yMax;
    if (sign >= 0) {
                throw new IllegalArgumentException(""Function values at endpoints do not have different signs."" + ""  Endpoints: ["" + min + "","" + max + ""]"" + ""  Values: ["" + yMin + "","" + yMax + ""]"");
    } else {
                ret = solve(min, yMin, max, yMax, min, yMin);
        }
    return ret;
}",1.3333333333333333,0.014150943396226528,0.5,0.0,0.6666666666666666,2.820689655172414,-0.9790520772381507,0.6666666666666666,-0.4,7.788373799001628
Math,99.0,3.0,"/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */
public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    return lcm;
}","/**
 * <p>
 * Returns the least common multiple of the absolute value of two numbers,
 * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.
 * </p>
 * Special cases:
 * <ul>
 * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and
 * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a
 * power of 2, throw an <code>ArithmeticException</code>, because the result
 * would be 2^31, which is too large for an int value.</li>
 * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is
 * <code>0</code> for any <code>x</code>.
 * </ul>
 *
 * @param a any number
 * @param b any number
 * @return the least common multiple, never negative
 * @throws ArithmeticException
 *             if the result cannot be represented as a nonnegative int
 *             value
 * @since 1.1
 */
","public static int lcm(int a, int b) {
    if (a == 0 || b == 0) {
        return 0;
    }
    int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
    return lcm;
}",0.16666666666666666,0.410377358490566,0.0,0.0,1.3333333333333333,2.910344827586207,-0.17530719719134008,0.0,-0.4,2.683652108568464
Math,105.0,1.0,"/**
 * Returns the <a href=""http://www.xycoon.com/SumOfSquares.htm"">
 * sum of squared errors</a> (SSE) associated with the regression
 * model.
 * <p>
 * The sum is computed using the computational formula
 * <p>
 * <code>SSE = SYY - (SXY * SXY / SXX)</code>
 * <p>
 * where <code>SYY</code> is the sum of the squared deviations of the y
 * values about their mean, <code>SXX</code> is similarly defined and
 * <code>SXY</code> is the sum of the products of x and y mean deviations.
 * <p>
 * The sums are accumulated using the updating algorithm referenced in
 * {@link #addData}.
 * <p>
 * The return value is constrained to be non-negative - i.e., if due to
 * rounding errors the computational formula returns a negative result,
 * 0 is returned.
 * <p>
 * <strong>Preconditions</strong>: <ul>
 * <li>At least two observations (with at least two different x values)
 * must have been added before invoking this method. If this method is
 * invoked before a model can be estimated, <code>Double,NaN</code> is
 * returned.
 * </li></ul>
 *
 * @return sum of squared errors associated with the regression model
 */
public double getSumSquaredErrors() {
    return sumYY - sumXY * sumXY / sumXX;
}","/**
 * Returns the <a href=""http://www.xycoon.com/SumOfSquares.htm"">
 * sum of squared errors</a> (SSE) associated with the regression
 * model.
 * <p>
 * The sum is computed using the computational formula
 * <p>
 * <code>SSE = SYY - (SXY * SXY / SXX)</code>
 * <p>
 * where <code>SYY</code> is the sum of the squared deviations of the y
 * values about their mean, <code>SXX</code> is similarly defined and
 * <code>SXY</code> is the sum of the products of x and y mean deviations.
 * <p>
 * The sums are accumulated using the updating algorithm referenced in
 * {@link #addData}.
 * <p>
 * The return value is constrained to be non-negative - i.e., if due to
 * rounding errors the computational formula returns a negative result,
 * 0 is returned.
 * <p>
 * <strong>Preconditions</strong>: <ul>
 * <li>At least two observations (with at least two different x values)
 * must have been added before invoking this method. If this method is
 * invoked before a model can be estimated, <code>Double,NaN</code> is
 * returned.
 * </li></ul>
 *
 * @return sum of squared errors associated with the regression model
 */
","public double getSumSquaredErrors() {
    return sumYY - sumXY * sumXY / sumXX;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.8275862068965517,0.7674663545933295,-1.0,-0.3875,0.23187990910880107
Time,26.0,2.0,"public long roundCeiling(long instant) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        instant = iField.roundCeiling(instant + offset);
        return instant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.roundCeiling(localInstant);
        return iZone.convertLocalToUTC(localInstant, false);
    }
}","/**
 * {@inheritDoc}
 */
","public long roundCeiling(long instant) {
    if (iTimeField) {
        int offset = getOffsetToAdd(instant);
        instant = iField.roundCeiling(instant + offset);
        return instant - offset;
    } else {
        long localInstant = iZone.convertUTCToLocal(instant);
        localInstant = iField.roundCeiling(localInstant);
        return iZone.convertLocalToUTC(localInstant, false);
    }
}",0.8333333333333334,0.9103773584905657,0.0,0.0,0.6666666666666666,1.4965517241379311,-0.6012873025160909,0.6666666666666666,-0.325,1.9386305487466677
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1051_25cf3ccd,3.0,"@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    String sep = """";
    for (ByteSequence auth : auths) {
        sb.append(sep);
        sep = "","";
        sb.append(new String(auth.toArray()));
    }
    return sb.toString();
}","/**
 * {@inheritDoc}
 */
","@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    String sep = """";
    for (ByteSequence auth : auths) {
        sb.append(sep);
        sep = "","";
        sb.append(new String(auth.toArray()));
    }
    return sb.toString();
}",0.8333333333333334,0.7783018867924528,0.0,0.0,0.0,0.0,-0.5689877121123461,0.3333333333333333,-0.1125,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1190_e29dc4f5,3.0,"public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {
    send_update(writer, cells);
    recv_update();
}","/**
 * {@inheritDoc}
 */
","public void update(String writer, Map<ByteBuffer, List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {
    send_update(writer, cells);
    recv_update();
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.29233469865418377,-0.3333333333333333,-0.4,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_994df698,1.0,"@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}","/**
 * {@inheritDoc}
 */
","@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5240491515506138,-0.6666666666666666,0.13749999999999998,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e,1.0,"@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}","/**
 * {@inheritDoc}
 */
","@Override
public void addMutation(Mutation m) throws MutationsRejectedException {
    acu.addMutation(tablename, m);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5240491515506138,-0.6666666666666666,0.13749999999999998,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-1505_b082fc1e,1.0,"@Override
public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {
    for (Mutation m : iterable) {
        acu.addMutation(tablename, m);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {
    for (Mutation m : iterable) {
        acu.addMutation(tablename, m);
    }
}",0.0,0.8066037735849054,0.0,0.0,0.0,0.0,0.08917495611468695,-0.6666666666666666,-0.15,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-209_76d727f0,1.0,"private boolean matches(Matcher matcher, ByteSequence bs) {
    if (matcher != null) {
        babcs.set(bs);
        matcher.reset(babcs);
        return matcher.matches();
    }
    return !orFields;
}","/**
 * {@inheritDoc}
 */
","private boolean matches(Matcher matcher, ByteSequence bs) {
    if (matcher != null) {
        babcs.set(bs);
        matcher.reset(babcs);
        return matcher.matches();
    }
    return !orFields;
}",0.3333333333333333,0.9386792452830187,0.0,0.0,0.6666666666666666,1.0689655172413794,-0.21977764774722083,0.0,-0.15,0.7776565099926643
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1.0,"@Override
public Collection<Text> getSplits(String tableName) {
    return Collections.emptyList();
}","/**
 * {@inheritDoc}
 */
","@Override
public Collection<Text> getSplits(String tableName) {
    return Collections.emptyList();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5362200117027491,-0.6666666666666666,0.3875,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1.0,"@Override
public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    acu.tables.remove(tableName);
}","/**
 * {@inheritDoc}
 */
","@Override
public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    acu.tables.remove(tableName);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.44493856056173153,-0.6666666666666666,-0.3,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_46f62443,1.0,"@Override
public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {
    MockTable t = acu.tables.remove(oldTableName);
    acu.tables.put(newTableName, t);
}","/**
 * {@inheritDoc}
 */
","@Override
public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException, TableExistsException {
    MockTable t = acu.tables.remove(oldTableName);
    acu.tables.put(newTableName, t);
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.07653598595669936,-0.3333333333333333,-0.4,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1.0,"@Override
public void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {
    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {
        throw new IllegalArgumentException();
    }
    acu.createTable(username, tableName, versioningIter, timeType);
}","/**
 * {@inheritDoc}
 */
","@Override
public void create(String tableName, boolean versioningIter, TimeType timeType) throws AccumuloException, AccumuloSecurityException, TableExistsException {
    if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {
        throw new IllegalArgumentException();
    }
    acu.createTable(username, tableName, versioningIter, timeType);
}",0.16666666666666666,0.6367924528301884,0.5,0.0,0.6666666666666666,0.0,-0.20947922761849064,-0.3333333333333333,-0.4,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-217_add180fb,1.0,"@Override
public Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {
    return acu.tables.get(tableName).settings.entrySet();
}","/**
 * {@inheritDoc}
 */
","@Override
public Iterable<Entry<String, String>> getProperties(String tableName) throws TableNotFoundException {
    return acu.tables.get(tableName).settings.entrySet();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.35833820947922745,-0.3333333333333333,-0.3875,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2487_f2920c26,0.0,"/**
 * Get the data from the BytesWritable.
 *
 * @return The data is only valid between 0 and getSize() - 1.
 */
public byte[] get() {
    if (this.value == null) {
        throw new IllegalStateException(""Uninitialized. Null constructor "" + ""called w/o accompanying readFields invocation"");
    }
    return this.value;
}","/**
 * Get the data from the BytesWritable.
 *
 * @return The data is only valid between 0 and getSize() - 1.
 */
","public byte[] get() {
    if (this.value == null) {
        throw new IllegalStateException(""Uninitialized. Null constructor "" + ""called w/o accompanying readFields invocation"");
    }
    return this.value;
}",0.0,0.5896226415094338,0.5,0.0,0.6666666666666666,0.786206896551724,0.18139262726740774,-1.0,0.825,0.25929040453740315
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2494_0dc92ca1,1.0,"public void clear() {
    sum = 0;
    count = 0;
    partialStdDev = 0;
}","/**
 * {@inheritDoc}
 */
","public void clear() {
    sum = 0;
    count = 0;
    partialStdDev = 0;
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.34757167934464567,-1.0,0.7500000000000002,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2659_019edb16,0.0,"@Override
protected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {
    List<IteratorSetting> iterators = null;
    if (null == split) {
        iterators = getIterators(job);
    } else {
        iterators = split.getIterators();
    }
    setupIterators(iterators, scanner);
}","/**
 * {@inheritDoc}
 */
","@Override
protected void setupIterators(JobConf job, Scanner scanner, String tableName, org.apache.accumulo.core.client.mapred.RangeInputSplit split) {
    List<IteratorSetting> iterators = null;
    if (null == split) {
        iterators = getIterators(job);
    } else {
        iterators = split.getIterators();
    }
    setupIterators(iterators, scanner);
}",0.6666666666666666,0.6367924528301884,0.0,0.0,0.6666666666666666,1.0,-0.5966062024575775,0.0,-0.3875,1.718273067220125
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-2742_1f7dd2d5,1.0,"@Override
public String next() {
    return super.next().toString();
}","/**
 * {@inheritDoc}
 */
","@Override
public String next() {
    return super.next().toString();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.7103569338794619,-0.3333333333333333,0.32499999999999996,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3077_17654199,0.0,"protected static void initMetadataConfig() throws IOException {
    initMetadataConfig(RootTable.ID);
    initMetadataConfig(MetadataTable.ID);
}","/**
 * {@inheritDoc}
 */
","protected static void initMetadataConfig() throws IOException {
    initMetadataConfig(RootTable.ID);
    initMetadataConfig(MetadataTable.ID);
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.5858396723229949,-0.3333333333333333,-0.025000000000000026,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-334_9d8cc45d,1.0,"@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    return new ColumnAgeOffFilter(getSource(), ttls, currentTime);
}","/**
 * {@inheritDoc}
 */
","@Override
public SortedKeyValueIterator<Key, Value> deepCopy(IteratorEnvironment env) {
    return new ColumnAgeOffFilter(getSource(), ttls, currentTime);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.43604447045055555,-0.6666666666666666,-0.325,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-3408_81d25bc2,3.0,"public static String bigNumber(long big, String[] SUFFIXES, long base) {
    return String.format(""%,d"", big);
}","/**
 * {@inheritDoc}
 */
","public static String bigNumber(long big, String[] SUFFIXES, long base) {
    return String.format(""%,d"", big);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7187829139847856,-0.6666666666666666,-0.4,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4029_5ca779a0,1.0,"@Override
public int hashCode() {
    return toThrift(false).hashCode();
}","/**
 * {@inheritDoc}
 */
","@Override
public int hashCode() {
    return toThrift(false).hashCode();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.7103569338794619,-0.3333333333333333,0.3875,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81,0.0,"public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {
    if (bytesList == null)
        return null;
    ArrayList<byte[]> result = new ArrayList<byte[]>();
    for (ByteBuffer bytes : bytesList) {
        result.add(toBytes(bytes));
    }
    return result;
}","/**
 * {@inheritDoc}
 */
","public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {
    if (bytesList == null)
        return null;
    ArrayList<byte[]> result = new ArrayList<byte[]>();
    for (ByteBuffer bytes : bytesList) {
        result.add(toBytes(bytes));
    }
    return result;
}",0.5,0.5141509433962262,0.5,0.0,0.6666666666666666,1.1517241379310346,-0.36255119953189,-0.3333333333333333,-0.23750000000000002,0.9990875096169329
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4113_27300d81,0.0,"public static Text toText(ByteBuffer bytes) {
    if (bytes == null)
        return null;
    Text result = new Text();
    result.set(bytes.array(), bytes.position(), bytes.remaining());
    return result;
}","/**
 * {@inheritDoc}
 */
","public static Text toText(ByteBuffer bytes) {
    if (bytes == null)
        return null;
    Text result = new Text();
    result.set(bytes.array(), bytes.position(), bytes.remaining());
    return result;
}",0.16666666666666666,0.410377358490566,0.0,-1.0,0.6666666666666666,1.2551724137931035,-0.15424224692802807,0.3333333333333333,-0.3500000000000001,1.0593476588359487
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_5594b2e0,1.0,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",1.3333333333333333,0.9103773584905657,0.0,0.0,0.0,0.0,-0.9116442363955529,1.6666666666666667,-0.4,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7,1.0,"/**
 * Iterates over the source until an acceptable key/value pair is found.
 */
protected void findTop() {
    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {
        try {
            getSource().next();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}","/**
 * Iterates over the source until an acceptable key/value pair is found.
 */
","protected void findTop() {
    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {
        try {
            getSource().next();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}",0.5,2.014150943396226,1.0,1.0,2.3333333333333335,0.9172413793103449,-0.32463428905792857,2.0,0.23750000000000002,0.653987225134637
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-412_be2fdba7,1.0,"@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void run() {
    ClientService.Iface client = null;
    try {
        client = ServerClient.getConnection(HdfsZooInstance.getInstance());
        List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);
        attempt.removeAll(fail);
        filesToLoad.removeAll(attempt);
    } catch (Exception ex) {
        log.error(ex, ex);
    } finally {
        ServerClient.close(client);
    }
}",1.3333333333333333,0.9103773584905657,0.0,0.0,0.0,0.0,-0.9116442363955529,1.6666666666666667,-0.4,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-4138_50db442b,1.0,"public static Option startRowOpt() {
    final Option o = new Option(START_ROW_OPT, ""begin-row"", true, ""begin row (inclusive)"");
    o.setArgName(""begin-row"");
    return o;
}","/**
 * {@inheritDoc}
 */
","public static Option startRowOpt() {
    final Option o = new Option(START_ROW_OPT, ""begin-row"", true, ""begin row (inclusive)"");
    o.setArgName(""begin-row"");
    return o;
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.23101228788765357,-0.6666666666666666,-0.23750000000000002,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3.0,"@Override
public void clearLocatorCache(String tableName) throws TableNotFoundException {
    throw new NotImplementedException();
}","/**
 * {@inheritDoc}
 */
","@Override
public void clearLocatorCache(String tableName) throws TableNotFoundException {
    throw new NotImplementedException();
}",-0.3333333333333333,-0.3726415094339622,0.0,-1.0,0.0,0.0,0.6162668227033345,-1.0,0.55,0.0
accumulo,remotes/origin/bugs-dot-jar_ACCUMULO-843_65390f8c,3.0,"@Override
public void merge(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}","/**
 * {@inheritDoc}
 */
","@Override
public void merge(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {
    throw new NotImplementedException();
}",-0.3333333333333333,-0.3726415094339622,0.0,-1.0,0.0,0.0,0.4060854300760682,-1.0,-0.3500000000000001,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff,1.0,"/**
 * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.
 *
 * @param uri  endpoint uri
 * @return the builder
 */
public InterceptFromDefinition interceptFrom(String uri) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.interceptFrom(uri);
}","/**
 * Adds a route for an interceptor that intercepts incoming messages on the given endpoint.
 *
 * @param uri  endpoint uri
 * @return the builder
 */
","public InterceptFromDefinition interceptFrom(String uri) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.interceptFrom(uri);
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.5006436512580451,0.0,0.825,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-3281_f7dd2fff,1.0,"/**
 * <a href=""http://camel.apache.org/exception-clause.html"">Exception clause</a>
 * for catching certain exceptions and handling them.
 *
 * @param exception exception to catch
 * @return the builder
 */
public OnExceptionDefinition onException(Class exception) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.onException(exception);
}","/**
 * <a href=""http://camel.apache.org/exception-clause.html"">Exception clause</a>
 * for catching certain exceptions and handling them.
 *
 * @param exception exception to catch
 * @return the builder
 */
","public OnExceptionDefinition onException(Class exception) {
    routeCollection.setCamelContext(getContext());
    return routeCollection.onException(exception);
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.5006436512580451,0.0,0.7500000000000002,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0.0,"public void addExceptionPolicy(OnExceptionDefinition exceptionType) {
    Processor processor = exceptionType.getErrorHandler();
    addChildService(processor);
    List<Class> list = exceptionType.getExceptionClasses();
    for (Class clazz : list) {
        ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());
        exceptionPolicies.put(key, exceptionType);
    }
}","/**
 * {@inheritDoc}
 */
","public void addExceptionPolicy(OnExceptionDefinition exceptionType) {
    Processor processor = exceptionType.getErrorHandler();
    addChildService(processor);
    List<Class> list = exceptionType.getExceptionClasses();
    for (Class clazz : list) {
        ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());
        exceptionPolicies.put(key, exceptionType);
    }
}",0.5,0.5141509433962262,0.0,0.0,0.0,0.0,-0.4617905207723817,0.6666666666666666,-0.375,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0.0,"public static ExceptionPolicyKey newInstance(Class exceptionClass) {
    return new ExceptionPolicyKey(exceptionClass, null);
}","/**
 * {@inheritDoc}
 */
","public static ExceptionPolicyKey newInstance(Class exceptionClass) {
    return new ExceptionPolicyKey(exceptionClass, null);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.83253364540667,-1.0,0.13749999999999998,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0.0,"public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {
    return new ExceptionPolicyKey(exceptionClass, when);
}","/**
 * {@inheritDoc}
 */
","public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {
    return new ExceptionPolicyKey(exceptionClass, when);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7581041544763012,-1.0,-0.1125,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-3448_b345dd82,0.0,"@Override
public String toString() {
    return ""ExceptionPolicyKey["" + exceptionClass + (when != null ? "" "" + when : """") + ""]"";
}","/**
 * {@inheritDoc}
 */
","@Override
public String toString() {
    return ""ExceptionPolicyKey["" + exceptionClass + (when != null ? "" "" + when : """") + ""]"";
}",-0.3333333333333333,-0.3726415094339622,0.0,-1.0,0.6666666666666666,0.7517241379310345,0.3634874195435926,-1.0,0.825,0.4333434721153674
camel,remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139,1.0,"private boolean writeFileByLocalWorkPath(File source, File file) {
    LOG.trace(""Using local work file being renamed from: {} to: {}"", source, file);
    return FileUtil.renameFile(source, file);
}","/**
 * {@inheritDoc}
 */
","private boolean writeFileByLocalWorkPath(File source, File file) {
    LOG.trace(""Using local work file being renamed from: {} to: {}"", source, file);
    return FileUtil.renameFile(source, file);
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.4004681100058508,-0.3333333333333333,-0.4,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139,1.0,"/**
 * Creates and prepares the output file channel. Will position itself in correct position if the file is writable
 *  eg. it should append or override any existing content.
 */
private FileChannel prepareOutputFileChannel(File target, FileChannel out) throws IOException {
    if (endpoint.getFileExist() == GenericFileExist.Append) {
        out = new RandomAccessFile(target, ""rw"").getChannel();
        out = out.position(out.size());
    } else {
        // will override
        out = new FileOutputStream(target).getChannel();
    }
    return out;
}","/**
 * Creates and prepares the output file channel. Will position itself in correct position if the file is writable
 *  eg. it should append or override any existing content.
 */
","private FileChannel prepareOutputFileChannel(File target, FileChannel out) throws IOException {
    if (endpoint.getFileExist() == GenericFileExist.Append) {
        out = new RandomAccessFile(target, ""rw"").getChannel();
        out = out.position(out.size());
    } else {
                out = new FileOutputStream(target).getChannel();
    }
    return out;
}",0.5,0.7783018867924528,0.0,0.0,1.0,1.0965517241379312,-0.4617905207723817,0.6666666666666666,-0.225,1.4968420675958563
camel,remotes/origin/bugs-dot-jar_CAMEL-3789_9319e139,1.0,"public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    lockFileName = file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;
    LOG.trace(""Locking the file: {} using the lock file name: {}"", file, lockFileName);
    // create a plain file as marker filer for locking (do not use FileLock)
    lock = new File(lockFileName);
    boolean acquired = lock.createNewFile();
    if (!acquired) {
        lock = null;
    }
    return acquired;
}","/**
 * {@inheritDoc}
 */
","public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations, GenericFile<File> file, Exchange exchange) throws Exception {
    lockFileName = file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;
    LOG.trace(""Locking the file: {} using the lock file name: {}"", file, lockFileName);
        lock = new File(lockFileName);
    boolean acquired = lock.createNewFile();
    if (!acquired) {
        lock = null;
    }
    return acquired;
}",0.6666666666666666,0.02358490566037727,0.0,0.0,0.6666666666666666,1.0206896551724138,-0.6036278525453477,0.0,-0.3875,1.7922742480900324
camel,remotes/origin/bugs-dot-jar_CAMEL-3878_b9094cb5,1.0,"@Override
protected void doStop() throws Exception {
    ServiceHelper.stopServices(deadLetter, output, outputAsync);
}","/**
 * {@inheritDoc}
 */
","@Override
protected void doStop() throws Exception {
    ServiceHelper.stopServices(deadLetter, output, outputAsync);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5362200117027491,-0.6666666666666666,-0.17500000000000004,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-5187_8cadc344,3.0,"public void unregister(ObjectName name) throws JMException {
    if (server.isRegistered(name)) {
        server.unregisterMBean(name);
        LOG.debug(""Unregistered MBean with ObjectName: {}"", name);
    }
    mbeansRegistered.remove(name);
}","/**
 * {@inheritDoc}
 */
","public void unregister(ObjectName name) throws JMException {
    if (server.isRegistered(name)) {
        server.unregisterMBean(name);
        LOG.debug(""Unregistered MBean with ObjectName: {}"", name);
    }
    mbeansRegistered.remove(name);
}",0.16666666666666666,0.8443396226415092,0.0,0.0,1.0,0.0,-0.1055588063194848,0.3333333333333333,-0.3625000000000001,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-5515_b3bb8670,1.0,"/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize    the core pool size
 * @param maxPoolSize the maximum pool size
 * @param threadName the thread pool name
 * @return the builder
 */
public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    answer.setMaxPoolSize(maxPoolSize);
    answer.setThreadName(threadName);
    addOutput(answer);
    return answer;
}","/**
 * Continues processing the {@link org.apache.camel.Exchange} using asynchronous routing engine.
 *
 * @param poolSize    the core pool size
 * @param maxPoolSize the maximum pool size
 * @param threadName the thread pool name
 * @return the builder
 */
","public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {
    ThreadsDefinition answer = threads();
    answer.setPoolSize(poolSize);
    answer.setMaxPoolSize(maxPoolSize);
    answer.setThreadName(threadName);
    addOutput(answer);
    return answer;
}",0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,-0.2558221181977765,0.6666666666666666,0.32499999999999996,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-5683_0c3c7d1b,1.0,"/**
 * Creates the {@link LRUCache} to be used.
 * <p/>
 * This implementation returns a {@link LRUSoftCache} instance.
 *
 * @param cacheSize the cache size
 * @return the cache
 */
protected static LRUCache<String, Producer> createLRUCache(int cacheSize) {
    // We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.
    return new LRUSoftCache<String, Producer>(cacheSize);
}","/**
 * Creates the {@link LRUCache} to be used.
 * <p/>
 * This implementation returns a {@link LRUSoftCache} instance.
 *
 * @param cacheSize the cache size
 * @return the cache
 */
","protected static LRUCache<String, Producer> createLRUCache(int cacheSize) {
        return new LRUSoftCache<String, Producer>(cacheSize);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7581041544763012,-1.0,0.8125,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-7016_4ed448c7,3.0,"public void updateRouteFromXml(String xml) throws Exception {
    // convert to model from xml
    RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);
    if (def == null) {
        return;
    }
    // add will remove existing route first
    context.addRouteDefinition(def);
}","/**
 * {@inheritDoc}
 */
","public void updateRouteFromXml(String xml) throws Exception {
        RouteDefinition def = ModelHelper.createModelFromXml(xml, RouteDefinition.class);
    if (def == null) {
        return;
    }
        context.addRouteDefinition(def);
}",0.16666666666666666,0.410377358490566,0.0,0.0,0.6666666666666666,0.9172413793103449,-0.1125804564072557,-0.3333333333333333,0.625,0.653987225134637
camel,remotes/origin/bugs-dot-jar_CAMEL-7055_15e1077d,1.0,"public void close() throws IOException {
    currentStream.close();
    cleanUpTempFile();
}","/**
 * {@inheritDoc}
 */
","public void close() throws IOException {
    currentStream.close();
    cleanUpTempFile();
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.7103569338794619,-0.3333333333333333,0.375,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-7213_336663c9,1.0,"@Converter
public static ByteBuffer toByteBuffer(Float value) {
    ByteBuffer buf = ByteBuffer.allocate(4);
    buf.putFloat(value);
    return buf;
}","/**
 * {@inheritDoc}
 */
","@Converter
public static ByteBuffer toByteBuffer(Float value) {
    ByteBuffer buf = ByteBuffer.allocate(4);
    buf.putFloat(value);
    return buf;
}",0.0,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.06717378583967239,-0.3333333333333333,0.18749999999999997,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-7213_336663c9,1.0,"@Converter
public static ByteBuffer toByteBuffer(Double value) {
    ByteBuffer buf = ByteBuffer.allocate(8);
    buf.putDouble(value);
    return buf;
}","/**
 * {@inheritDoc}
 */
","@Converter
public static ByteBuffer toByteBuffer(Double value) {
    ByteBuffer buf = ByteBuffer.allocate(8);
    buf.putDouble(value);
    return buf;
}",0.0,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.06717378583967239,-0.3333333333333333,0.15,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-7239_ae419224,1.0,"// Properties
// -----------------------------------------------------------------------
public Schema getSchema() throws IOException, SAXException {
    if (schema == null) {
        schema = createSchema();
    }
    return schema;
}","/**
 * {@inheritDoc}
 */
","public Schema getSchema() throws IOException, SAXException {
    if (schema == null) {
        schema = createSchema();
    }
    return schema;
}",0.0,0.5896226415094338,0.0,0.0,0.6666666666666666,0.8620689655172414,0.1364540667056754,-0.6666666666666666,0.8375,0.3566227120645542
camel,remotes/origin/bugs-dot-jar_CAMEL-7429_43956f93,1.0,"private String createConstantPart(String uri, int start, int end) {
    return uri.substring(start, end);
}","/**
 * {@inheritDoc}
 */
","private String createConstantPart(String uri, int start, int end) {
    return uri.substring(start, end);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7351667641895834,-0.6666666666666666,-0.3875,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-7456_02da984a,3.0,"public void setPropertySuffix(String propertySuffix) {
    this.propertySuffix = propertySuffix;
}","/**
 * {@inheritDoc}
 */
","public void setPropertySuffix(String propertySuffix) {
    this.propertySuffix = propertySuffix;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8910473961380918,-1.0,0.25000000000000006,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-7586_1f92fa42,3.0,"public boolean isMessageHistory() {
    return context.isMessageHistory();
}","/**
 * {@inheritDoc}
 */
","public boolean isMessageHistory() {
    return context.isMessageHistory();
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,1.1204212990052658,-0.6666666666666666,0.06249999999999999,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-8106_39ccf5d6,1.0,"@Override
public Object next() {
    Object o = nextToken;
    try {
        nextToken = getNextToken();
    } catch (XMLStreamException e) {
    // 
    }
    return o;
}","/**
 * {@inheritDoc}
 */
","@Override
public Object next() {
    Object o = nextToken;
    try {
        nextToken = getNextToken();
    } catch (XMLStreamException e) {
        }
    return o;
}",0.5,0.363207547169811,0.0,0.0,0.0,0.0,-0.2085430076067874,-0.6666666666666666,0.7749999999999999,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-8146_17475d80,3.0,"@Override
protected void doShutdown() throws Exception {
    if (shutdownExecutor && scheduledExecutorService != null) {
        getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);
        scheduledExecutorService = null;
        future = null;
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected void doShutdown() throws Exception {
    if (shutdownExecutor && scheduledExecutorService != null) {
        getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);
        scheduledExecutorService = null;
        future = null;
    }
}",0.3333333333333333,1.2594339622641506,0.0,0.0,1.3333333333333333,0.9379310344827587,-0.22679929783499106,0.0,-0.12500000000000003,0.706017068937754
camel,remotes/origin/bugs-dot-jar_CAMEL-8584_dd0f74c0,1.0,"private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {
    exchange.setException(new RejectedExecutionException(""CircuitBreaker Open: failures: "" + failures + "", lastFailure: "" + lastFailure));
    /*
         * If the circuit opens, we have to prevent the execution of any
         * processor. The failures count can be set to 0.
         */
    failures.set(0);
    callback.done(true);
    return true;
}","/**
 * {@inheritDoc}
 */
","private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {
    exchange.setException(new RejectedExecutionException(""CircuitBreaker Open: failures: "" + failures + "", lastFailure: "" + lastFailure));
        failures.set(0);
    callback.done(true);
    return true;
}",0.0,-0.2216981132075472,-0.5,-1.0,0.0,0.0,-0.03955529549444112,0.0,0.19999999999999998,0.0
camel,remotes/origin/bugs-dot-jar_CAMEL-8964_ea8ee025,1.0,"public synchronized void suspendRoute(String routeId) throws Exception {
    if (!routeSupportsSuspension(routeId)) {
        // stop if we suspend is not supported
        stopRoute(routeId);
        return;
    }
    RouteService routeService = routeServices.get(routeId);
    if (routeService != null) {
        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);
        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);
        routes.add(order);
        getShutdownStrategy().suspend(this, routes);
        // must suspend route service as well
        suspendRouteService(routeService);
    }
}","/**
 * {@inheritDoc}
 */
","public synchronized void suspendRoute(String routeId) throws Exception {
    if (!routeSupportsSuspension(routeId)) {
                stopRoute(routeId);
        return;
    }
    RouteService routeService = routeServices.get(routeId);
    if (routeService != null) {
        List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);
        RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);
        routes.add(order);
        getShutdownStrategy().suspend(this, routes);
                suspendRouteService(routeService);
    }
}",1.3333333333333333,0.7028301886792452,0.5,0.0,1.6666666666666667,1.0344827586206897,-0.9256875365710939,2.3333333333333335,-0.375,2.294680717825768
camel,remotes/origin/bugs-dot-jar_CAMEL-9143_08077733,1.0,"protected void doStop() throws Exception {
    // when stopping we intend to shutdown
    ServiceHelper.stopAndShutdownServices(statistics, pool);
    try {
        ServiceHelper.stopAndShutdownServices(producers.values());
    } finally {
        // ensure producers are removed, and also from JMX
        for (Producer producer : producers.values()) {
            getCamelContext().removeService(producer);
        }
    }
    producers.clear();
    if (statistics != null) {
        statistics.clear();
    }
}","/**
 * {@inheritDoc}
 */
","protected void doStop() throws Exception {
        ServiceHelper.stopAndShutdownServices(statistics, pool);
    try {
        ServiceHelper.stopAndShutdownServices(producers.values());
    } finally {
                for (Producer producer : producers.values()) {
            getCamelContext().removeService(producer);
        }
    }
    producers.clear();
    if (statistics != null) {
        statistics.clear();
    }
}",1.3333333333333333,0.9952830188679245,0.5,1.0,0.6666666666666666,0.0,-0.7407840842598008,1.6666666666666667,-0.25000000000000006,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-1045_a4ffd393,3.0,"/**
 * Checks whether the decomposed matrix is non-singular.
 *
 * @return true if the decomposed matrix is non-singular.
 */
public boolean isNonSingular() {
    for (int i = 0; i < realEigenvalues.length; ++i) {
        if (realEigenvalues[i] == 0 && imagEigenvalues[i] == 0) {
            return false;
        }
    }
    return true;
}","/**
 * Checks whether the decomposed matrix is non-singular.
 *
 * @return true if the decomposed matrix is non-singular.
 */
","public boolean isNonSingular() {
    for (int i = 0; i < realEigenvalues.length; ++i) {
        if (realEigenvalues[i] == 0 && imagEigenvalues[i] == 0) {
            return false;
        }
    }
    return true;
}",0.3333333333333333,1.6462264150943393,0.5,1.0,1.6666666666666667,2.4551724137931035,-0.27314218841427756,-1.0,0.7999999999999999,2.1314343990982447
commons-math,remotes/origin/bugs-dot-jar_MATH-1088_63d88c74,3.0,"/**
 * {@inheritDoc}
 */
public boolean hasNext() {
    for (int i = 0; i < dimension; i++) {
        if (counter[i] != size[i] - 1) {
            return true;
        }
    }
    return false;
}","/**
 * {@inheritDoc}
 */
","public boolean hasNext() {
    for (int i = 0; i < dimension; i++) {
        if (counter[i] != size[i] - 1) {
            return true;
        }
    }
    return false;
}",0.3333333333333333,1.6462264150943393,0.5,1.0,1.3333333333333333,1.9310344827586206,-0.24365125804564053,-1.0,0.8375,1.4875382440822316
commons-math,remotes/origin/bugs-dot-jar_MATH-1093_7cfbc0da,1.0,"/**
 * Create a split part.
 * @param tree BSP tree containing the limit angles of the split part
 * @return split part (may be null)
 */
private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {
    if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {
        return null;
    } else {
        return new ArcsSet(tree, getTolerance());
    }
}","/**
 * Create a split part.
 * @param tree BSP tree containing the limit angles of the split part
 * @return split part (may be null)
 */
","private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {
    if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {
        return null;
    } else {
        return new ArcsSet(tree, getTolerance());
    }
}",0.16666666666666666,0.8443396226415092,0.0,0.0,1.0,1.0,-0.12568753657109424,0.0,0.46249999999999997,0.7530371616181496
commons-math,remotes/origin/bugs-dot-jar_MATH-1148_4080feff,1.0,"public int compare(final Vector2D o1, final Vector2D o2) {
    final int diff = (int) FastMath.signum(o1.getX() - o2.getX());
    if (diff == 0) {
        return (int) FastMath.signum(o1.getY() - o2.getY());
    } else {
        return diff;
    }
}","/**
 * {@inheritDoc}
 */
","public int compare(final Vector2D o1, final Vector2D o2) {
    final int diff = (int) FastMath.signum(o1.getX() - o2.getX());
    if (diff == 0) {
        return (int) FastMath.signum(o1.getY() - o2.getY());
    } else {
        return diff;
    }
}",0.3333333333333333,0.6650943396226414,0.0,0.0,0.6666666666666666,1.3793103448275863,-0.3031012287887656,1.0,-0.28750000000000003,1.4169007532518652
commons-math,remotes/origin/bugs-dot-jar_MATH-1203_4aa4c6d3,1.0,"/**
 * The within-bin smoothing kernel. Returns a Gaussian distribution
 * parameterized by {@code bStats}, unless the bin contains only one
 * observation, in which case a constant distribution is returned.
 *
 * @param bStats summary statistics for the bin
 * @return within-bin kernel parameterized by bStats
 */
protected RealDistribution getKernel(SummaryStatistics bStats) {
    if (bStats.getN() == 1) {
        return new ConstantRealDistribution(bStats.getMean());
    } else {
        return new NormalDistribution(randomData.getRandomGenerator(), bStats.getMean(), bStats.getStandardDeviation(), NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
    }
}","/**
 * The within-bin smoothing kernel. Returns a Gaussian distribution
 * parameterized by {@code bStats}, unless the bin contains only one
 * observation, in which case a constant distribution is returned.
 *
 * @param bStats summary statistics for the bin
 * @return within-bin kernel parameterized by bStats
 */
","protected RealDistribution getKernel(SummaryStatistics bStats) {
    if (bStats.getN() == 1) {
        return new ConstantRealDistribution(bStats.getMean());
    } else {
        return new NormalDistribution(randomData.getRandomGenerator(), bStats.getMean(), bStats.getStandardDeviation(), NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
    }
}",0.16666666666666666,0.8443396226415092,0.0,0.0,0.6666666666666666,0.0,-0.15611468695143388,0.6666666666666666,-0.3125,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-1261_4c4b3e2e,3.0,"/**
 * Multiply the fraction by an integer.
 * @param i the {@code integer} to multiply by.
 * @return this * i
 */
@Override
public Fraction multiply(final int i) {
    return new Fraction(numerator * i, denominator);
}","/**
 * Multiply the fraction by an integer.
 * @param i the {@code integer} to multiply by.
 * @return this * i
 */
","@Override
public Fraction multiply(final int i) {
    return new Fraction(numerator * i, denominator);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5240491515506138,-1.0,0.85,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-290_b01fcc31,1.0,"/**
 * Get new versions of the constraints which have positive right hand sides.
 * @return new versions of the constraints
 */
public List<LinearConstraint> getNormalizedConstraints() {
    List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();
    for (LinearConstraint constraint : constraints) {
        normalized.add(normalize(constraint));
    }
    return normalized;
}","/**
 * Get new versions of the constraints which have positive right hand sides.
 * @return new versions of the constraints
 */
","public List<LinearConstraint> getNormalizedConstraints() {
    List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();
    for (LinearConstraint constraint : constraints) {
        normalized.add(normalize(constraint));
    }
    return normalized;
}",0.16666666666666666,0.410377358490566,0.0,0.0,0.0,0.0,-0.08917495611468695,-0.3333333333333333,0.6000000000000001,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-326_ce185345,1.0,"/**
 * {@inheritDoc}
 */
public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}","/**
 * {@inheritDoc}
 */
","public double getNorm() {
    double sum = 0;
    for (double a : data) {
        sum += a * a;
    }
    return Math.sqrt(sum);
}",0.16666666666666666,0.410377358490566,0.0,0.0,0.0,1.0344827586206897,-0.044704505558806215,-0.6666666666666666,0.8375,0.5570843248465764
commons-math,remotes/origin/bugs-dot-jar_MATH-326_ce185345,1.0,"/**
 * {@inheritDoc}
 */
public double getLInfNorm() {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        max += iter.value();
    }
    return max;
}","/**
 * {@inheritDoc}
 */
","public double getLInfNorm() {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        max += iter.value();
    }
    return max;
}",0.5,0.5141509433962262,0.0,0.0,0.6666666666666666,1.0,-0.30918665886483326,0.3333333333333333,0.6375000000000001,0.7319246390295396
commons-math,remotes/origin/bugs-dot-jar_MATH-326_ce185345,1.0,"/**
 * {@inheritDoc}
 */
public double getNorm() {
    double res = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res += iter.value() * iter.value();
    }
    return Math.sqrt(res);
}","/**
 * {@inheritDoc}
 */
","public double getNorm() {
    double res = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res += iter.value() * iter.value();
    }
    return Math.sqrt(res);
}",0.5,0.5141509433962262,0.0,0.0,0.6666666666666666,1.0620689655172415,-0.38502047981275617,1.0,0.33749999999999997,1.0569859190209516
commons-math,remotes/origin/bugs-dot-jar_MATH-349_4cc9a49d,3.0,"/**
 * Set the Poisson mean for the distribution. The mean value must be
 * positive; otherwise an <code>IllegalArgument</code> is thrown.
 *
 * @param z the new distribution
 * @param p the Poisson mean value
 * @throws IllegalArgumentException if p &le; 0
 */
private void setNormalAndMeanInternal(NormalDistribution z, double p) {
    if (p <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
    }
    mean = p;
    normal = z;
    normal.setMean(p);
    normal.setStandardDeviation(FastMath.sqrt(p));
}","/**
 * Set the Poisson mean for the distribution. The mean value must be
 * positive; otherwise an <code>IllegalArgument</code> is thrown.
 *
 * @param z the new distribution
 * @param p the Poisson mean value
 * @throws IllegalArgumentException if p &le; 0
 */
","private void setNormalAndMeanInternal(NormalDistribution z, double p) {
    if (p <= 0) {
        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
    }
    mean = p;
    normal = z;
    normal.setMean(p);
    normal.setStandardDeviation(FastMath.sqrt(p));
}",0.5,0.13679245283018865,0.5,0.0,0.6666666666666666,1.0344827586206897,-0.43464014043300137,0.3333333333333333,0.5375000000000001,1.2086382422930346
commons-math,remotes/origin/bugs-dot-jar_MATH-349_4cc9a49d,3.0,"/**
 * Modify the normal distribution used to compute normal approximations. The
 * caller is responsible for insuring the normal distribution has the proper
 * parameter settings.
 *
 * @param value the new distribution
 * @since 1.2
 * @deprecated as of 2.1 (class will become immutable in 3.0)
 */
@Deprecated
public void setNormal(NormalDistribution value) {
    setNormalAndMeanInternal(value, mean);
}","/**
 * Modify the normal distribution used to compute normal approximations. The
 * caller is responsible for insuring the normal distribution has the proper
 * parameter settings.
 *
 * @param value the new distribution
 * @since 1.2
 * @deprecated as of 2.1 (class will become immutable in 3.0)
 */
","@Deprecated
public void setNormal(NormalDistribution value) {
    setNormalAndMeanInternal(value, mean);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.59426565242832,-0.6666666666666666,0.7999999999999999,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-367_3a15d8ce,3.0,"/**
 * {@inheritDoc}
 */
public Entry next() {
    tmp.setIndex(current.getIndex());
    if (next != null) {
        current.setIndex(next.getIndex());
        advance(next);
        if (next.getIndex() < 0) {
            next = null;
        }
    } else {
        current = null;
    }
    return tmp;
}","/**
 * {@inheritDoc}
 */
","public Entry next() {
    tmp.setIndex(current.getIndex());
    if (next != null) {
        current.setIndex(next.getIndex());
        advance(next);
        if (next.getIndex() < 0) {
            next = null;
        }
    } else {
        current = null;
    }
    return tmp;
}",1.1666666666666667,1.146226415094339,0.5,1.0,1.3333333333333333,1.586206896551724,-0.6841427735517848,1.0,0.11249999999999998,1.6446297257161262
commons-math,remotes/origin/bugs-dot-jar_MATH-369_f4a4464b,3.0,"/**
 * {@inheritDoc}
 */
public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    return solve(min, max);
}","/**
 * {@inheritDoc}
 */
","public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException {
    return solve(min, max);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.6841427735517848,-0.6666666666666666,0.55,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-370_495f04bc,3.0,"/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) this method}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 * @deprecated This method considers that {@code NaN == NaN}. In release
 * 3.0, the semantics will change in order to comply with IEEE754 where it
 * is specified that {@code NaN != NaN}.
 * New methods have been added for those cases wher the old semantics is
 * useful (see e.g. {@link #equalsIncludingNaN(double,double)
 * equalsIncludingNaN}.
 */
public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}","/**
 * Returns true iff they are equal as defined by
 * {@link #equals(double,double,int) this method}.
 *
 * @param x first value
 * @param y second value
 * @return {@code true} if the values are equal.
 * @deprecated This method considers that {@code NaN == NaN}. In release
 * 3.0, the semantics will change in order to comply with IEEE754 where it
 * is specified that {@code NaN != NaN}.
 * New methods have been added for those cases wher the old semantics is
 * useful (see e.g. {@link #equalsIncludingNaN(double,double)
 * equalsIncludingNaN}.
 */
","public static boolean equals(double x, double y) {
    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,1.3793103448275863,0.6298420128730241,-0.3333333333333333,0.3625,0.6806104739582401
commons-math,remotes/origin/bugs-dot-jar_MATH-370_495f04bc,3.0,"/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}
 */
@Deprecated
public static double nextAfter(double d, double direction) {
    return FastMath.nextAfter(d, direction);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 * @since 1.2
 * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}
 */
","@Deprecated
public static double nextAfter(double d, double direction) {
    return FastMath.nextAfter(d, direction);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5858396723229949,-0.6666666666666666,-0.4,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-373_bfe4623c,1.0,"/**
 * {@inheritDoc}
 */
@Override
public void increment(final double d) {
    if (n == 0) {
        value = d;
    } else {
        value *= d;
    }
    n++;
}","/**
 * {@inheritDoc}
 */
","@Override
public void increment(final double d) {
    if (n == 0) {
        value = d;
    } else {
        value *= d;
    }
    n++;
}",0.5,0.7783018867924528,0.0,0.0,0.6666666666666666,2.1655172413793107,-0.2352252779403161,-1.0,0.8375,1.1672004437208139
commons-math,remotes/origin/bugs-dot-jar_MATH-395_962315ba,1.0,"/**
 * {@inheritDoc}
 */
public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());
}","/**
 * {@inheritDoc}
 */
","public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
    clearResult();
    return localMin(f, goalType, min, startValue, max, getRelativeAccuracy(), getAbsoluteAccuracy());
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.29093036863662963,0.3333333333333333,-0.375,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-395_962315ba,1.0,"/**
 * Temporary workaround.
 */
protected double doOptimize() {
    throw new UnsupportedOperationException();
}","/**
 * Temporary workaround.
 */
","protected double doOptimize() {
    throw new UnsupportedOperationException();
}",-0.5,-0.2216981132075472,0.0,-1.0,0.0,0.0,1.1794031597425385,-1.0,0.8375,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-699_b2e24119,3.0,"public double value(double x) {
    return cumulativeProbability(x) - p;
}","/**
 * {@inheritDoc}
 */
","public double value(double x) {
    return cumulativeProbability(x) - p;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8653013458162657,-0.6666666666666666,0.7749999999999999,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-744_8a83581e,1.0,"/**
 * <p>
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * </p>
 *
 * @return the fraction as a <tt>double</tt>
 * @see java.lang.Number#doubleValue()
 */
@Override
public double doubleValue() {
    return numerator.doubleValue() / denominator.doubleValue();
}","/**
 * <p>
 * Gets the fraction as a <tt>double</tt>. This calculates the fraction as
 * the numerator divided by denominator.
 * </p>
 *
 * @return the fraction as a <tt>double</tt>
 * @see java.lang.Number#doubleValue()
 */
","@Override
public double doubleValue() {
    return numerator.doubleValue() / denominator.doubleValue();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.6143943826799294,-0.3333333333333333,0.8125,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1.0,"/**
 * Clear the array contents, resetting the number of elements to zero.
 */
@Override
public synchronized void clear() {
    numElements = 0;
    startIndex = 0;
}","/**
 * Clear the array contents, resetting the number of elements to zero.
 */
","@Override
public synchronized void clear() {
    numElements = 0;
    startIndex = 0;
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.39625511995318896,-1.0,0.825,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1.0,"/**
 * Notice the package scope on this method.   This method is simply here
 * for the JUnit test, it allows us check if the expansion is working
 * properly after a number of expansions.  This is not meant to be a part
 * of the public interface of this class.
 *
 * @return the length of the internal storage array.
 * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.
 */
@Deprecated
synchronized int getInternalLength() {
    return internalArray.length;
}","/**
 * Notice the package scope on this method.   This method is simply here
 * for the JUnit test, it allows us check if the expansion is working
 * properly after a number of expansions.  This is not meant to be a part
 * of the public interface of this class.
 *
 * @return the length of the internal storage array.
 * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.
 */
","@Deprecated
synchronized int getInternalLength() {
    return internalArray.length;
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.7548273844353419,-1.0,0.5125000000000001,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1.0,"/**
 * Returns the number of elements currently in the array.  Please note
 * that this is different from the length of the internal storage array.
 *
 * @return the number of elements.
 */
@Override
public synchronized int getNumElements() {
    return numElements;
}","/**
 * Returns the number of elements currently in the array.  Please note
 * that this is different from the length of the internal storage array.
 *
 * @return the number of elements.
 */
","@Override
public synchronized int getNumElements() {
    return numElements;
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.8456407255705085,-1.0,0.825,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-757_76b7413d,1.0,"/**
 * Returns true if the internal storage array has too many unused
 * storage positions.
 *
 * @return true if array satisfies the contraction criteria
 */
private synchronized boolean shouldContract() {
    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {
        return (internalArray.length / ((float) numElements)) > contractionCriterion;
    } else {
        return (internalArray.length - numElements) > contractionCriterion;
    }
}","/**
 * Returns true if the internal storage array has too many unused
 * storage positions.
 *
 * @return true if array satisfies the contraction criteria
 */
","private synchronized boolean shouldContract() {
    if (expansionMode == ExpansionMode.MULTIPLICATIVE) {
        return (internalArray.length / ((float) numElements)) > contractionCriterion;
    } else {
        return (internalArray.length - numElements) > contractionCriterion;
    }
}",0.16666666666666666,0.8443396226415092,0.0,0.0,0.6666666666666666,1.9931034482758623,-0.1055588063194848,-1.0,0.8125,1.377109015762824
commons-math,remotes/origin/bugs-dot-jar_MATH-812_6eb46555,1.0,"/**
 * {@inheritDoc}
 */
@Override
public double dotProduct(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return dotProduct((OpenMapRealVector) v);
    } else {
        return super.dotProduct(v);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public double dotProduct(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return dotProduct((OpenMapRealVector) v);
    } else {
        return super.dotProduct(v);
    }
}",0.3333333333333333,0.9386792452830187,0.0,0.0,0.6666666666666666,0.0,-0.020830895260386527,-0.3333333333333333,0.7875,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-835_63a48705,3.0,"/**
 * <p>
 * Gets the fraction percentage as a <tt>double</tt>. This calculates the
 * fraction as the numerator divided by denominator multiplied by 100.
 * </p>
 *
 * @return the fraction percentage as a <tt>double</tt>.
 */
public double percentageValue() {
    return multiply(100).doubleValue();
}","/**
 * <p>
 * Gets the fraction percentage as a <tt>double</tt>. This calculates the
 * fraction as the numerator divided by denominator multiplied by 100.
 * </p>
 *
 * @return the fraction percentage as a <tt>double</tt>.
 */
","public double percentageValue() {
    return multiply(100).doubleValue();
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9729666471620824,-0.3333333333333333,0.8125,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-859_66dece12,1.0,"/**
 * {@inheritDoc}
 */
public boolean isSupportLowerBoundInclusive() {
    return true;
}","/**
 * {@inheritDoc}
 */
","public boolean isSupportLowerBoundInclusive() {
    return true;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,1.190169689877121,-1.0,0.7999999999999999,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-880_2a9cbbab,1.0,"/**
 * Mark the outgoing edge as processed.
 */
public void outgoingProcessed() {
    outgoingNeedsProcessing = false;
}","/**
 * Mark the outgoing edge as processed.
 */
","public void outgoingProcessed() {
    outgoingNeedsProcessing = false;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9729666471620824,-1.0,0.85,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-891_2b852d79,1.0,"/**
 * Applies rank transform to each of the columns of <code>matrix</code>
 * using the current <code>rankingAlgorithm</code>
 *
 * @param matrix matrix to transform
 */
private void rankTransform(RealMatrix matrix) {
    for (int i = 0; i < matrix.getColumnDimension(); i++) {
        matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));
    }
}","/**
 * Applies rank transform to each of the columns of <code>matrix</code>
 * using the current <code>rankingAlgorithm</code>
 *
 * @param matrix matrix to transform
 */
","private void rankTransform(RealMatrix matrix) {
    for (int i = 0; i < matrix.getColumnDimension(); i++) {
        matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));
    }
}",-0.16666666666666666,0.8160377358490566,0.0,0.0,1.0,1.1310344827586207,0.10509069631363387,0.3333333333333333,-0.17500000000000004,0.936322484836557
commons-math,remotes/origin/bugs-dot-jar_MATH-939_49444ee6,1.0,"/**
 * Compute a covariance matrix from a rectangular array whose columns represent
 * covariates.
 * @param data input array (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the data array does not contain sufficient
 * data
 */
protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {
    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);
}","/**
 * Compute a covariance matrix from a rectangular array whose columns represent
 * covariates.
 * @param data input array (must have at least two columns and two rows)
 * @param biasCorrected determines whether or not covariance estimates are bias-corrected
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the data array does not contain sufficient
 * data
 */
","protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) throws MathIllegalArgumentException {
    return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7581041544763012,-0.6666666666666666,0.8375,0.0
commons-math,remotes/origin/bugs-dot-jar_MATH-939_49444ee6,1.0,"/**
 * Create a covariance matrix from a rectangular array whose columns represent
 * covariates. Covariances are computed using the bias-corrected formula.
 * @param data input array (must have at least two columns and two rows)
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the data array does not contain sufficient data
 * @see #Covariance
 */
protected RealMatrix computeCovarianceMatrix(double[][] data) throws MathIllegalArgumentException {
    return computeCovarianceMatrix(data, true);
}","/**
 * Create a covariance matrix from a rectangular array whose columns represent
 * covariates. Covariances are computed using the bias-corrected formula.
 * @param data input array (must have at least two columns and two rows)
 * @return covariance matrix
 * @throws MathIllegalArgumentException if the data array does not contain sufficient data
 * @see #Covariance
 */
","protected RealMatrix computeCovarianceMatrix(double[][] data) throws MathIllegalArgumentException {
    return computeCovarianceMatrix(data, true);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.83253364540667,-0.6666666666666666,0.825,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-1214_6ecd0f82,1.0,"@Override
public void computeInterestingPropertiesForInputs(CostEstimator estimator) {
    // get what we inherit and what is preserved by our user code
    final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);
    // add all properties relevant to this node
    for (OperatorDescriptorSingle dps : getPossibleProperties()) {
        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {
            props.addGlobalProperties(gp);
        }
        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {
            props.addLocalProperties(lp);
        }
    }
    this.inConn.setInterestingProperties(props);
    for (PactConnection conn : getBroadcastConnections()) {
        conn.setInterestingProperties(new InterestingProperties());
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void computeInterestingPropertiesForInputs(CostEstimator estimator) {
        final InterestingProperties props = getInterestingProperties().filterByCodeAnnotations(this, 0);
        for (OperatorDescriptorSingle dps : getPossibleProperties()) {
        for (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {
            props.addGlobalProperties(gp);
        }
        for (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {
            props.addLocalProperties(lp);
        }
    }
    this.inConn.setInterestingProperties(props);
    for (PactConnection conn : getBroadcastConnections()) {
        conn.setInterestingProperties(new InterestingProperties());
    }
}",1.6666666666666667,1.495283018867924,1.5,1.0,0.0,0.0,-1.0010532475131653,2.3333333333333335,-0.3875,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-1640_8f321c72,1.0,"/**
 *  Normalizes a path string.
 *
 *  @param path
 *         the path string to normalize
 *  @return the normalized path string
 */
private String normalizePath(String path) {
    // remove double slashes & backslashes
    path = path.replace(""//"", ""/"");
    path = path.replace(""\\"", ""/"");
    return path;
}","/**
 *  Normalizes a path string.
 *
 *  @param path
 *         the path string to normalize
 *  @return the normalized path string
 */
","private String normalizePath(String path) {
        path = path.replace(""//"", ""/"");
    path = path.replace(""\\"", ""/"");
    return path;
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.1982445874780572,-0.3333333333333333,0.6750000000000002,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-1705_5308ac83,1.0,"/**
 *  Returns the host name of the instance. If the host name could not be determined, the return value will be a
 *  textual representation of the instance's IP address.
 *
 *  @return the host name of the instance
 */
public String getFQDNHostname() {
    return this.fqdnHostName;
}","/**
 *  Returns the host name of the instance. If the host name could not be determined, the return value will be a
 *  textual representation of the instance's IP address.
 *
 *  @return the host name of the instance
 */
","public String getFQDNHostname() {
    return this.fqdnHostName;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,1.063779988297249,-1.0,0.7625000000000002,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0.0,"/**
 *  Static utility to parse a field of type byte from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final byte parseField(byte[] bytes, int startPos, int length) {
    return parseField(bytes, startPos, length, (char) 0xffff);
}","/**
 *  Static utility to parse a field of type byte from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final byte parseField(byte[] bytes, int startPos, int length) {
    return parseField(bytes, startPos, length, (char) 0xffff);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7782328847279106,-0.6666666666666666,0.4875,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-1820_39d526e6,0.0,"/**
 *  Static utility to parse a field of type short from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
public static final short parseField(byte[] bytes, int startPos, int length) {
    return parseField(bytes, startPos, length, (char) 0xffff);
}","/**
 *  Static utility to parse a field of type short from a byte sequence that represents text characters
 *  (such as when read from a file stream).
 *
 *  @param bytes The bytes containing the text data that should be parsed.
 *  @param startPos The offset to start the parsing.
 *  @param length The length of the byte sequence (counting from the offset).
 *
 *  @return The parsed value.
 *
 *  @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 */
","public static final short parseField(byte[] bytes, int startPos, int length) {
    return parseField(bytes, startPos, length, (char) 0xffff);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7782328847279106,-0.6666666666666666,0.525,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-2109_d594d024,1.0,"/**
 *  Marks task execution failed for an external reason (a reason other than th task code itself
 *  throwing an exception). If the task is already in a terminal state
 *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.
 *  Otherwise it sets the state to FAILED, and, if the invokable code is running,
 *  starts an asynchronous thread that aborts that code.
 *
 *  <p>This method never blocks.</p>
 */
public void failExternally(Throwable cause) {
    LOG.info(""Attempting to fail task externally "" + taskNameWithSubtask);
    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);
}","/**
 *  Marks task execution failed for an external reason (a reason other than th task code itself
 *  throwing an exception). If the task is already in a terminal state
 *  (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.
 *  Otherwise it sets the state to FAILED, and, if the invokable code is running,
 *  starts an asynchronous thread that aborts that code.
 *
 *  <p>This method never blocks.</p>
 */
","public void failExternally(Throwable cause) {
    LOG.info(""Attempting to fail task externally "" + taskNameWithSubtask);
    cancelOrFailAndCancelInvokable(ExecutionState.FAILED, cause);
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.41685196021064935,-0.3333333333333333,0.06249999999999999,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-2460_a17d4e82,1.0,"@Override
public boolean isReleased() {
    return isReleased;
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean isReleased() {
    return isReleased;
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.9022820362785252,-1.0,0.475,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-2713_63d9800e,1.0,"@Override
public S value() throws IOException {
    return state;
}","/**
 * {@inheritDoc}
 */
","@Override
public S value() throws IOException {
    return state;
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.6846108835576357,-1.0,0.7625000000000002,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-2964_76bebd42,0.0,"/**
 *  Gets the number of memory segments used by this partition, which includes build side
 *  memory buffers and overflow memory segments.
 *
 *  @return The number of occupied memory segments.
 */
public int getNumOccupiedMemorySegments() {
    // either the number of memory segments, or one for spilling
    final int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;
    return numPartitionBuffers + numOverflowSegments;
}","/**
 *  Gets the number of memory segments used by this partition, which includes build side
 *  memory buffers and overflow memory segments.
 *
 *  @return The number of occupied memory segments.
 */
","public int getNumOccupiedMemorySegments() {
        final int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;
    return numPartitionBuffers + numOverflowSegments;
}",-0.3333333333333333,-0.11792452830188677,0.0,-1.0,0.6666666666666666,0.8620689655172414,0.4145114101813919,-1.0,0.7500000000000002,0.4023545830276789
flink,remotes/origin/bugs-dot-jar_FLINK-3189_a5b05566,3.0,"public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {
    try {
        PosixParser parser = new PosixParser();
        CommandLine line = parser.parse(INFO_OPTIONS, args, false);
        return new InfoOptions(line);
    } catch (ParseException e) {
        throw new CliArgsException(e.getMessage());
    }
}","/**
 * {@inheritDoc}
 */
","public static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {
    try {
        PosixParser parser = new PosixParser();
        CommandLine line = parser.parse(INFO_OPTIONS, args, false);
        return new InfoOptions(line);
    } catch (ParseException e) {
        throw new CliArgsException(e.getMessage());
    }
}",0.5,0.9575471698113206,0.5,0.0,0.0,0.0,-0.4107665301345817,-0.3333333333333333,0.037499999999999964,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b,1.0,"@Override
public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {
    context.window = mergeResult;
    // store for later use
    mergeTriggerResult.f0 = context.onMerge(mergedWindows);
    for (W m : mergedWindows) {
        context.window = m;
        context.clear();
    }
    // merge the merged state windows into the newly resulting state window
    getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);
}","/**
 * {@inheritDoc}
 */
","@Override
public void merge(W mergeResult, Collection<W> mergedWindows, W stateWindowResult, Collection<W> mergedStateWindows) throws Exception {
    context.window = mergeResult;
        mergeTriggerResult.f0 = context.onMerge(mergedWindows);
    for (W m : mergedWindows) {
        context.window = m;
        context.clear();
    }
        getStateBackend().mergePartitionedStates(stateWindowResult, mergedStateWindows, windowSerializer, (StateDescriptor<? extends MergingState<?, ?>, ?>) windowStateDescriptor);
}",0.6666666666666666,0.6367924528301884,0.0,0.0,0.0,0.0,-0.6284376828554705,0.3333333333333333,-0.4,0.0
flink,remotes/origin/bugs-dot-jar_FLINK-3740_f2f5bd5b,1.0,"@Override
public final void close() throws Exception {
    super.close();
}","/**
 * {@inheritDoc}
 */
","@Override
public final void close() throws Exception {
    super.close();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.7913399648917492,-0.6666666666666666,0.525,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1054_0adf3a6e,1.0,"@Override
public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {
    Tree node = parentBefore.getChild(name);
    if (isAdminUser(node)) {
        String msg = ""The admin user cannot be removed."";
        throw constraintViolation(27, msg);
    }
    return null;
}","/**
 * {@inheritDoc}
 */
","@Override
public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {
    Tree node = parentBefore.getChild(name);
    if (isAdminUser(node)) {
        String msg = ""The admin user cannot be removed."";
        throw constraintViolation(27, msg);
    }
    return null;
}",0.5,0.7783018867924528,0.5,0.0,1.0,0.0,-0.4243417203042712,0.0,-0.25000000000000006,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1096_be44b816,1.0,"@Override
public QueryResult execute() throws RepositoryException {
    return manager.executeQuery(statement, language, limit, offset, bindVariableMap);
}","/**
 * {@inheritDoc}
 */
","@Override
public QueryResult execute() throws RepositoryException {
    return manager.executeQuery(statement, language, limit, offset, bindVariableMap);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.43604447045055555,-0.6666666666666666,-0.375,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1178_f2bb1a17,1.0,"// ---------------------------------------------------------< internal >---
private NodeState getBase() {
    if (parent == null) {
        return root.getBaseState();
    } else {
        return parent.getBase().getChildNode(name);
    }
}","/**
 * {@inheritDoc}
 */
","private NodeState getBase() {
    if (parent == null) {
        return root.getBaseState();
    } else {
        return parent.getBase().getChildNode(name);
    }
}",0.16666666666666666,0.8443396226415092,0.0,0.0,0.6666666666666666,0.0,0.01942656524283168,0.0,0.7749999999999999,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1215_a9efe3c4,0.0,"private boolean matchesPropertyType(PropertyValue value) {
    if (value == null) {
        return false;
    }
    if (propertyType == PropertyType.UNDEFINED) {
        return true;
    }
    return value.getType().tag() == propertyType;
}","/**
 * {@inheritDoc}
 */
","private boolean matchesPropertyType(PropertyValue value) {
    if (value == null) {
        return false;
    }
    if (propertyType == PropertyType.UNDEFINED) {
        return true;
    }
    return value.getType().tag() == propertyType;
}",0.5,0.5141509433962262,0.5,0.0,1.3333333333333333,0.0,-0.3068461088355765,-0.3333333333333333,0.12499999999999999,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1227_117b0a3d,1.0,"@Override
public boolean hasNode(String relPath) throws RepositoryException {
    final String oakPath = getOakPathOrThrow(relPath);
    return perform(new NodeOperation<Boolean>(dlg) {

        @Override
        public Boolean perform() throws RepositoryException {
            return node.getChild(oakPath) != null;
        }
    });
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean hasNode(String relPath) throws RepositoryException {
    final String oakPath = getOakPathOrThrow(relPath);
    return perform(new NodeOperation<Boolean>(dlg) {

        @Override
        public Boolean perform() throws RepositoryException {
            return node.getChild(oakPath) != null;
        }
    });
}",0.6666666666666666,1.693396226415094,-0.5,0.0,0.0,1.013793103448276,-0.45944997074312427,0.0,0.42500000000000004,1.0297185593387128
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1287_14849e22,1.0,"private synchronized RecordId writeListBucket(List<RecordId> bucket) {
    RecordId bucketId = prepare(RecordType.BUCKET, 0, bucket);
    for (RecordId id : bucket) {
        writeRecordId(id);
    }
    return bucketId;
}","/**
 * {@inheritDoc}
 */
","private synchronized RecordId writeListBucket(List<RecordId> bucket) {
    RecordId bucketId = prepare(RecordType.BUCKET, 0, bucket);
    for (RecordId id : bucket) {
        writeRecordId(id);
    }
    return bucketId;
}",0.16666666666666666,0.410377358490566,0.0,0.0,0.0,0.0,-0.13130485664131095,-0.3333333333333333,-0.3375000000000001,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1320_64045631,1.0,"/**
 * Merge all changes tracked in this builder into the underlying store.
 */
NodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {
    purge();
    branch.merge(hook, info);
    return reset();
}","/**
 * Merge all changes tracked in this builder into the underlying store.
 */
","NodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {
    purge();
    branch.merge(hook, info);
    return reset();
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.2380339379754238,0.0,0.7875,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_05c89637,1.0,"/**
 * Get the value for the given key if the entry is cached. This method does
 * not modify the internal state.
 *
 * @param key the key (may not be null)
 * @return the value, or null if there is no resident entry
 */
public V peek(K key) {
    Entry<K, V> e = find(key);
    return e == null ? null : e.value;
}","/**
 * Get the value for the given key if the entry is cached. This method does
 * not modify the internal state.
 *
 * @param key the key (may not be null)
 * @return the value, or null if there is no resident entry
 */
","public V peek(K key) {
    Entry<K, V> e = find(key);
    return e == null ? null : e.value;
}",-0.3333333333333333,-0.11792452830188677,0.0,-1.0,0.6666666666666666,1.103448275862069,0.32650672908133366,-0.6666666666666666,0.5375000000000001,0.7389382906013491
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1364_05c89637,1.0,"/**
 * Get the entry set for all resident entries.
 *
 * @return the entry set
 */
public synchronized Set<Map.Entry<K, V>> entrySet() {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keySet()) {
        map.put(k, find(k).value);
    }
    return map.entrySet();
}","/**
 * Get the entry set for all resident entries.
 *
 * @return the entry set
 */
","public synchronized Set<Map.Entry<K, V>> entrySet() {
    HashMap<K, V> map = new HashMap<K, V>();
    for (K k : keySet()) {
        map.put(k, find(k).value);
    }
    return map.entrySet();
}",0.16666666666666666,0.410377358490566,0.0,0.0,0.0,0.0,-0.20807489760093645,0.3333333333333333,0.012500000000000013,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1460_f1ba7a42,1.0,"@Override
public Resolution addExistingProperty(NodeBuilder parent, PropertyState ours, PropertyState theirs) {
    if (isChildOrderProperty(ours)) {
        // that was previously unordered.
        return Resolution.THEIRS;
    } else {
        return handler.addExistingProperty(parent, ours, theirs);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public Resolution addExistingProperty(NodeBuilder parent, PropertyState ours, PropertyState theirs) {
    if (isChildOrderProperty(ours)) {
                return Resolution.THEIRS;
    } else {
        return handler.addExistingProperty(parent, ours, theirs);
    }
}",0.3333333333333333,0.9386792452830187,0.0,0.0,1.0,0.0,-0.21228788765359832,-0.3333333333333333,-0.275,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1467_dde7de85,1.0,"private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {
    DocumentStore store = nodeStore.getDocumentStore();
    for (UpdateOp op : changed) {
        UpdateOp reverse = op.getReverseOperation();
        store.createOrUpdate(NODES, reverse);
    }
    for (UpdateOp op : newDocuments) {
        store.remove(NODES, op.id);
    }
    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);
    NodeDocument.removeCollision(removeCollision, revision);
    store.createOrUpdate(NODES, removeCollision);
}","/**
 * {@inheritDoc}
 */
","private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {
    DocumentStore store = nodeStore.getDocumentStore();
    for (UpdateOp op : changed) {
        UpdateOp reverse = op.getReverseOperation();
        store.createOrUpdate(NODES, reverse);
    }
    for (UpdateOp op : newDocuments) {
        store.remove(NODES, op.id);
    }
    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);
    NodeDocument.removeCollision(removeCollision, revision);
    store.createOrUpdate(NODES, removeCollision);
}",1.1666666666666667,0.3160377358490565,0.5,0.0,0.0,0.0,-0.8863662960795783,1.3333333333333333,-0.4,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1739_8188ef54,1.0,"@Override
public boolean evaluate() {
    // JCR 2.0 spec, 6.7.16 Comparison:
    // ""operand1 may evaluate to an array of values""
    PropertyValue p1 = operand1.currentProperty();
    if (p1 == null) {
        return false;
    }
    PropertyValue p2 = operand2.currentValue();
    if (p2 == null) {
        // even for ""null <> 'x'"" (same as in SQL)
        return false;
    }
    // property type of the value of operand1""
    try {
        p2 = convertValueToType(p2, p1);
    } catch (IllegalArgumentException ex) {
        // unable to convert, just skip this node
        return false;
    }
    return evaluate(p1, p2);
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean evaluate() {
            PropertyValue p1 = operand1.currentProperty();
    if (p1 == null) {
        return false;
    }
    PropertyValue p2 = operand2.currentValue();
    if (p2 == null) {
                return false;
    }
        try {
        p2 = convertValueToType(p2, p1);
    } catch (IllegalArgumentException ex) {
                return false;
    }
    return evaluate(p1, p2);
}",1.8333333333333333,0.410377358490566,1.0,0.0,1.3333333333333333,1.2413793103448276,-0.9640725570509064,0.3333333333333333,-0.17500000000000004,1.684994006190621
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_016df669,1.0,"/**
 * Add a new or update an existing map entry.
 * The property is a map of revisions / values.
 *
 * @param property the property
 * @param revision the revision
 * @param value the value
 */
void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {
    Operation op = new Operation();
    op.type = Operation.Type.SET_MAP_ENTRY;
    op.value = value;
    changes.put(new Key(property, checkNotNull(revision)), op);
}","/**
 * Add a new or update an existing map entry.
 * The property is a map of revisions / values.
 *
 * @param property the property
 * @param revision the revision
 * @param value the value
 */
","void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {
    Operation op = new Operation();
    op.type = Operation.Type.SET_MAP_ENTRY;
    op.value = value;
    changes.put(new Key(property, checkNotNull(revision)), op);
}",0.0,-0.2216981132075472,-0.5,-1.0,0.0,0.0,-0.14347571679344628,-0.3333333333333333,0.55,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1822_3e83a4c1,1.0,"public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {
    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
}","/**
 * {@inheritDoc}
 */
","public static void setModified(@Nonnull UpdateOp op, @Nonnull Revision revision) {
    checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.5844353423054408,0.6666666666666666,-0.325,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1874_3ae276c1,1.0,"@Override
public void enter(NodeState before, NodeState after) throws CommitFailedException {
    collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME));
    // no-op when reindex is empty
    CommitFailedException exception = EditorDiff.process(CompositeEditor.compose(reindex.values()), MISSING_NODE, after);
    if (exception != null) {
        throw exception;
    }
    for (Editor editor : editors) {
        editor.enter(before, after);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void enter(NodeState before, NodeState after) throws CommitFailedException {
    collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME));
        CommitFailedException exception = EditorDiff.process(CompositeEditor.compose(reindex.values()), MISSING_NODE, after);
    if (exception != null) {
        throw exception;
    }
    for (Editor editor : editors) {
        editor.enter(before, after);
    }
}",0.8333333333333334,0.5141509433962262,1.0,0.0,0.6666666666666666,0.9586206896551723,-0.6799297834991223,1.0,-0.375,1.572131470183035
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1877_716e1237,0.0,"@Override
public void indexUpdate() throws CommitFailedException {
    if (!dirty) {
        dirty = true;
        preAsyncRun(store, name);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void indexUpdate() throws CommitFailedException {
    if (!dirty) {
        dirty = true;
        preAsyncRun(store, name);
    }
}",0.16666666666666666,1.1367924528301885,0.0,0.0,0.6666666666666666,0.7655172413793104,0.009596255119953104,-0.6666666666666666,0.45000000000000007,0.33014259898731463
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1977_4bfbfcdd,1.0,"/**
 * Creates a cursor which wraps another cursor and adds a path prefix to
 * each of row of the wrapped cursor. This method will return the passed
 * cursor as is if {@code path} is the empty string or the root path (""/"").
 *
 * @param c    the cursor to wrap.
 * @param path the path prefix.
 * @return the cursor.
 */
public static Cursor newPrefixCursor(Cursor c, String path) {
    if (path.isEmpty() || PathUtils.denotesRoot(path)) {
        // no need to wrap
        return c;
    }
    return new PrefixCursor(c, path);
}","/**
 * Creates a cursor which wraps another cursor and adds a path prefix to
 * each of row of the wrapped cursor. This method will return the passed
 * cursor as is if {@code path} is the empty string or the root path (""/"").
 *
 * @param c    the cursor to wrap.
 * @param path the path prefix.
 * @return the cursor.
 */
","public static Cursor newPrefixCursor(Cursor c, String path) {
    if (path.isEmpty() || PathUtils.denotesRoot(path)) {
                return c;
    }
    return new PrefixCursor(c, path);
}",0.0,0.5896226415094338,0.0,0.0,1.6666666666666667,0.0,0.041895845523697864,-0.3333333333333333,0.11249999999999998,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-1985_f620b79b,1.0,"@Nonnull
private static String getKeyValue(String key, String userId) {
    return key + userId;
}","/**
 * {@inheritDoc}
 */
","@Nonnull
private static String getKeyValue(String key, String userId) {
    return key + userId;
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5170275014628429,-1.0,0.3000000000000001,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2029_e30023ba,1.0,"/**
 * close writer if it's not null
 */
void closeWriter() throws IOException {
    if (writer != null) {
        writer.close();
    }
}","/**
 * close writer if it's not null
 */
","void closeWriter() throws IOException {
    if (writer != null) {
        writer.close();
    }
}",-0.16666666666666666,0.8160377358490566,0.0,0.0,0.6666666666666666,0.0,0.4145114101813919,-0.6666666666666666,0.8375,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-208_daf9a4ef,1.0,"// ------------------------------------------------------------< private >---
/**
 * Purge all pending changes to the underlying {@link NodeStoreBranch}.
 * All registered {@link PurgeListener}s are notified.
 */
private void purgePendingChanges() {
    if (hasPendingChanges()) {
        branch.setRoot(rootTree.getNodeState());
    }
    notifyListeners();
}","/**
 * Purge all pending changes to the underlying {@link NodeStoreBranch}.
 * All registered {@link PurgeListener}s are notified.
 */
","private void purgePendingChanges() {
    if (hasPendingChanges()) {
        branch.setRoot(rootTree.getNodeState());
    }
    notifyListeners();
}",0.0,0.5896226415094338,0.0,0.0,0.6666666666666666,0.0,0.26003510825043835,0.3333333333333333,0.8375,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2249_6dde8e9d,1.0,"@Override
public void restrict(FilterImpl f) {
    if (propertyName != null) {
        if (f.getSelector().equals(selector)) {
            String pn = normalizePropertyName(propertyName);
            f.restrictProperty(pn, Operator.NOT_EQUAL, null);
        }
    }
    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));
}","/**
 * {@inheritDoc}
 */
","@Override
public void restrict(FilterImpl f) {
    if (propertyName != null) {
        if (f.getSelector().equals(selector)) {
            String pn = normalizePropertyName(propertyName);
            f.restrictProperty(pn, Operator.NOT_EQUAL, null);
        }
    }
    f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));
}",0.6666666666666666,2.1462264150943393,0.5,1.0,1.6666666666666667,0.8758620689655173,-0.5633703920421295,1.3333333333333333,-0.3,1.2528671879193432
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2250_08b25cb0,3.0,"private Map<String, PropertyDefinition> collectPropertyDefns(NodeBuilder defn) {
    Map<String, PropertyDefinition> propDefns = newHashMap();
    NodeBuilder propNode = defn.getChildNode(LuceneIndexConstants.PROP_NODE);
    for (String propName : Iterables.concat(includes, orderedProps)) {
        NodeBuilder propDefnNode;
        if (relativeProps.containsKey(propName)) {
            propDefnNode = relativeProps.get(propName).getPropDefnNode(propNode);
        } else {
            propDefnNode = propNode.getChildNode(propName);
        }
        if (propDefnNode.exists()) {
            propDefns.put(propName, new PropertyDefinition(this, propName, propDefnNode));
        }
    }
    return ImmutableMap.copyOf(propDefns);
}","/**
 * {@inheritDoc}
 */
","private Map<String, PropertyDefinition> collectPropertyDefns(NodeBuilder defn) {
    Map<String, PropertyDefinition> propDefns = newHashMap();
    NodeBuilder propNode = defn.getChildNode(LuceneIndexConstants.PROP_NODE);
    for (String propName : Iterables.concat(includes, orderedProps)) {
        NodeBuilder propDefnNode;
        if (relativeProps.containsKey(propName)) {
            propDefnNode = relativeProps.get(propName).getPropDefnNode(propNode);
        } else {
            propDefnNode = propNode.getChildNode(propName);
        }
        if (propDefnNode.exists()) {
            propDefns.put(propName, new PropertyDefinition(this, propName, propDefnNode));
        }
    }
    return ImmutableMap.copyOf(propDefns);
}",1.6666666666666667,1.495283018867924,1.0,1.0,1.6666666666666667,0.0,-1.084844938560561,2.3333333333333335,-0.4,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2330_408a566e,3.0,"@Override
public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {
    boolean dirty = false;
    if (result.pd.ordered) {
        dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);
    }
    dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);
    if (dirty) {
        dirtyFlag.set(true);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailedException {
    boolean dirty = false;
    if (result.pd.ordered) {
        dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);
    }
    dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, true, result.pd);
    if (dirty) {
        dirtyFlag.set(true);
    }
}",0.8333333333333334,0.5141509433962262,0.5,0.0,1.3333333333333333,1.2137931034482758,-0.7023990637799877,0.0,-0.4,2.281583797033512
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2420_24cb1908,0.0,"@Override
public NodeDocument apply(String name) {
    String p = concat(path, name);
    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));
    if (doc == null) {
        docChildrenCache.invalidateAll();
        throw new NullPointerException(""Document "" + p + "" not found"");
    }
    return doc;
}","/**
 * {@inheritDoc}
 */
","@Override
public NodeDocument apply(String name) {
    String p = concat(path, name);
    NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));
    if (doc == null) {
        docChildrenCache.invalidateAll();
        throw new NullPointerException(""Document "" + p + "" not found"");
    }
    return doc;
}",0.6666666666666666,0.6367924528301884,0.5,0.0,0.6666666666666666,0.9103448275862069,-0.5895845523698066,0.3333333333333333,0.037499999999999964,1.4457426061441019
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2528_239de7b8,1.0,"private void addGarbage(Revision rev, String property) {
    Set<Revision> revisions = garbage.get(property);
    if (revisions == null) {
        revisions = Sets.newHashSet();
        garbage.put(property, revisions);
    }
    revisions.add(rev);
}","/**
 * {@inheritDoc}
 */
","private void addGarbage(Revision rev, String property) {
    Set<Revision> revisions = garbage.get(property);
    if (revisions == null) {
        revisions = Sets.newHashSet();
        garbage.put(property, revisions);
    }
    revisions.add(rev);
}",0.3333333333333333,0.6650943396226414,0.0,0.0,0.6666666666666666,1.103448275862069,-0.32978349912229366,0.3333333333333333,-0.3500000000000001,1.263745504642966
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2642_36fe017c,0.0,"/**
 * Creates a new commit. The caller must acknowledge the commit either with
 * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},
 * depending on the result of the commit.
 *
 * @param base the base revision for the commit or <code>null</code> if the
 *             commit should use the current head revision as base.
 * @param branch the branch instance if this is a branch commit. The life
 *               time of this branch commit is controlled by the
 *               reachability of this parameter. Once {@code branch} is
 *               weakly reachable, the document store implementation is
 *               free to remove the commits associated with the branch.
 * @return a new commit.
 */
@Nonnull
Commit newCommit(@Nullable Revision base, @Nullable DocumentNodeStoreBranch branch) {
    if (base == null) {
        base = headRevision;
    }
    backgroundOperationLock.readLock().lock();
    boolean success = false;
    Commit c;
    try {
        c = new Commit(this, commitQueue.createRevision(), base, branch);
        success = true;
    } finally {
        if (!success) {
            backgroundOperationLock.readLock().unlock();
        }
    }
    return c;
}","/**
 * Creates a new commit. The caller must acknowledge the commit either with
 * {@link #done(Commit, boolean, CommitInfo)} or {@link #canceled(Commit)},
 * depending on the result of the commit.
 *
 * @param base the base revision for the commit or <code>null</code> if the
 *             commit should use the current head revision as base.
 * @param branch the branch instance if this is a branch commit. The life
 *               time of this branch commit is controlled by the
 *               reachability of this parameter. Once {@code branch} is
 *               weakly reachable, the document store implementation is
 *               free to remove the commits associated with the branch.
 * @return a new commit.
 */
","@Nonnull
Commit newCommit(@Nullable Revision base, @Nullable DocumentNodeStoreBranch branch) {
    if (base == null) {
        base = headRevision;
    }
    backgroundOperationLock.readLock().lock();
    boolean success = false;
    Commit c;
    try {
        c = new Commit(this, commitQueue.createRevision(), base, branch);
        success = true;
    } finally {
        if (!success) {
            backgroundOperationLock.readLock().unlock();
        }
    }
    return c;
}",2.0,0.9575471698113206,0.5,1.0,1.3333333333333333,1.1172413793103448,-1.0787595084844934,0.6666666666666666,-0.4,2.125064858385071
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2691_d2da7499,0.0,"/**
 * Retrieves the {# CLUSTER_ID_PROP}
 *
 * @param store the NodeStore instance
 * @return the repository id
 */
public static String getId(NodeStore store) {
    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);
}","/**
 * Retrieves the {# CLUSTER_ID_PROP}
 *
 * @param store the NodeStore instance
 * @return the repository id
 */
","public static String getId(NodeStore store) {
    return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.6092451726155637,0.3333333333333333,0.8375,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-276_1bf5c550,1.0,"@Override
public boolean markNode(Id id) throws Exception {
    return touch(id, gcStart);
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean markNode(Id id) throws Exception {
    return touch(id, gcStart);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.5493270918665877,-0.6666666666666666,0.46249999999999997,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-278_db19e70f,1.0,"private void buildPath(StringBuilder sb) {
    if (isRemoved()) {
        throw new IllegalStateException(""Cannot build the path of a removed tree"");
    }
    if (!isRoot()) {
        parent.buildPath(sb);
        sb.append('/').append(name);
    }
}","/**
 * {@inheritDoc}
 */
","private void buildPath(StringBuilder sb) {
    if (isRemoved()) {
        throw new IllegalStateException(""Cannot build the path of a removed tree"");
    }
    if (!isRoot()) {
        parent.buildPath(sb);
        sb.append('/').append(name);
    }
}",0.5,0.7783018867924528,1.0,0.0,1.3333333333333333,0.0,-0.30356933879461656,0.6666666666666666,0.23750000000000002,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-2799_3979fa8d,1.0,"@Override
public void close() {
    file.blob = null;
    file.data = null;
}","/**
 * {@inheritDoc}
 */
","@Override
public void close() {
    file.blob = null;
    file.data = null;
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.3316559391456988,-1.0,0.5875000000000001,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3104_38f5ef13,3.0,"private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {
    DocumentStore store = nodeStore.getDocumentStore();
    for (UpdateOp op : changed) {
        UpdateOp reverse = op.getReverseOperation();
        store.findAndUpdate(NODES, reverse);
    }
    for (UpdateOp op : newDocuments) {
        UpdateOp reverse = op.getReverseOperation();
        store.findAndUpdate(NODES, reverse);
    }
    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);
    NodeDocument.removeCollision(removeCollision, revision);
    store.findAndUpdate(NODES, removeCollision);
}","/**
 * {@inheritDoc}
 */
","private void rollback(List<UpdateOp> newDocuments, List<UpdateOp> changed, UpdateOp commitRoot) {
    DocumentStore store = nodeStore.getDocumentStore();
    for (UpdateOp op : changed) {
        UpdateOp reverse = op.getReverseOperation();
        store.findAndUpdate(NODES, reverse);
    }
    for (UpdateOp op : newDocuments) {
        UpdateOp reverse = op.getReverseOperation();
        store.findAndUpdate(NODES, reverse);
    }
    UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);
    NodeDocument.removeCollision(removeCollision, revision);
    store.findAndUpdate(NODES, removeCollision);
}",1.3333333333333333,0.410377358490566,0.5,0.0,0.0,0.0,-0.9547103569338787,1.6666666666666667,-0.4,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3104_38f5ef13,3.0,"public static void setDeleted(@Nonnull UpdateOp op, @Nonnull Revision revision, boolean deleted) {
    if (deleted) {
        // DELETED_ONCE would be set upon every delete.
        // possibly we can avoid that
        checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);
    }
    checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision), String.valueOf(deleted));
}","/**
 * {@inheritDoc}
 */
","public static void setDeleted(@Nonnull UpdateOp op, @Nonnull Revision revision, boolean deleted) {
    if (deleted) {
                        checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);
    }
    checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision), String.valueOf(deleted));
}",0.0,0.5896226415094338,0.0,0.0,0.6666666666666666,0.0,-0.09291983616149788,1.0,-0.325,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3110_d10362c0,1.0,"public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {
    Directory local = createLocalDirForIndexWriter(definition);
    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));
}","/**
 * {@inheritDoc}
 */
","public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {
    Directory local = createLocalDirForIndexWriter(definition);
    return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.3040374488004682,-0.3333333333333333,-0.3625000000000001,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-3324_5f863af6,1.0,"@Nonnull
private Iterator<PermissionEntry> getEntryIterator(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {
    return getEntryIterator(new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions)));
}","/**
 * {@inheritDoc}
 */
","@Nonnull
private Iterator<PermissionEntry> getEntryIterator(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {
    return getEntryIterator(new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions)));
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.3096547688706842,-0.3333333333333333,-0.3875,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-421_36e70bd7,1.0,"@Override
public void reset(NodeState newBase) {
    if (this == root) {
        baseState = checkNotNull(newBase);
        writeState = new MutableNodeState(baseState);
        revision++;
    } else {
        throw new IllegalStateException(""Cannot reset a non-root builder"");
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void reset(NodeState newBase) {
    if (this == root) {
        baseState = checkNotNull(newBase);
        writeState = new MutableNodeState(baseState);
        revision++;
    } else {
        throw new IllegalStateException(""Cannot reset a non-root builder"");
    }
}",0.6666666666666666,1.1273584905660372,0.5,0.0,0.6666666666666666,0.793103448275862,-0.4187244002340551,-0.6666666666666666,0.5875000000000001,0.6275786799305791
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-428_916cd92f,1.0,"/**
 * Splits a {@code jsonString}, which is prefixed with a type code
 * at the location where the prefix ends.
 * @param jsonString  json string to split
 * @return  the location where the prefix ends or -1 if no prefix is present
 */
public static int split(String jsonString) {
    if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {
        return 3;
    } else {
        return -1;
    }
}","/**
 * Splits a {@code jsonString}, which is prefixed with a type code
 * at the location where the prefix ends.
 * @param jsonString  json string to split
 * @return  the location where the prefix ends or -1 if no prefix is present
 */
","public static int split(String jsonString) {
    if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {
        return 3;
    } else {
        return -1;
    }
}",0.16666666666666666,0.8443396226415092,0.0,0.0,1.3333333333333333,1.793103448275862,-0.09853715623171459,-0.3333333333333333,0.6875000000000001,1.2044157377753126
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1.0,"void apply() throws Exception {
    moveNode(srcPath, destPath);
}","/**
 * {@inheritDoc}
 */
","void apply() throws Exception {
    moveNode(srcPath, destPath);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9027501462843762,-0.6666666666666666,0.4,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1.0,"void apply() throws Exception {
    setProperty(nodePath, propName, propValue);
}","/**
 * {@inheritDoc}
 */
","void apply() throws Exception {
    setProperty(nodePath, propName, propValue);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8451726155646576,-0.6666666666666666,-0.13750000000000004,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-43_668f08f2,1.0,"void apply() throws Exception {
    setProperties(nodePath, properties);
}","/**
 * {@inheritDoc}
 */
","void apply() throws Exception {
    setProperties(nodePath, properties);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9027501462843762,-0.6666666666666666,0.33749999999999997,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-4431_7441a3d5,1.0,"public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {
    Directory local = createLocalDirForIndexReader(indexPath, definition);
    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));
}","/**
 * {@inheritDoc}
 */
","public Directory wrapForRead(String indexPath, IndexDefinition definition, Directory remote) throws IOException {
    Directory local = createLocalDirForIndexReader(indexPath, definition);
    return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.2567583382094791,-0.3333333333333333,-0.4,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-47_b62f1c26,1.0,"public String toString() {
    return ""simple:"" + name;
}","/**
 * {@inheritDoc}
 */
","public String toString() {
    return ""simple:"" + name;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9027501462843762,-1.0,0.7999999999999999,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-498_f2a2edec,1.0,"@Override
public boolean parent() {
    if (elements.isEmpty() || "".."".equals(elements.get(elements.size() - 1))) {
        elements.add("".."");
        return true;
    }
    elements.remove(elements.size() - 1);
    return true;
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean parent() {
    if (elements.isEmpty() || "".."".equals(elements.get(elements.size() - 1))) {
        elements.add("".."");
        return true;
    }
    elements.remove(elements.size() - 1);
    return true;
}",0.5,0.7783018867924528,0.0,0.0,2.0,1.1655172413793105,-0.38923346986541807,1.3333333333333333,-0.4,1.182945375820794
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-531_90c45a02,1.0,"/**
 * Determine whether the named child has been removed. This is the
 * case when the write state has a corresponding {@code null} entry.
 * Assumes {@code read()}, {@code write()} needs not be called.
 * @param name  name of the child
 * @return  {@code true} iff a child with the given name has been removed
 */
private boolean removed(String name) {
    return writeState != null && writeState.isRemoved(name);
}","/**
 * Determine whether the named child has been removed. This is the
 * case when the write state has a corresponding {@code null} entry.
 * Assumes {@code read()}, {@code write()} needs not be called.
 * @param name  name of the child
 * @return  {@code true} iff a child with the given name has been removed
 */
","private boolean removed(String name) {
    return writeState != null && writeState.isRemoved(name);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.8896551724137931,0.7052077238150961,-0.6666666666666666,0.7625000000000002,0.3208387754736899
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3.0,"@Override
public String getPlan(NodeState rootState) {
    StringBuilder buff = new StringBuilder();
    buff.append(toString());
    buff.append("" /* "").append(index.getPlan(createFilter(), rootState));
    if (selectorCondition != null) {
        buff.append("" where "").append(selectorCondition);
    }
    buff.append("" */"");
    return buff.toString();
}","/**
 * {@inheritDoc}
 */
","@Override
public String getPlan(NodeState rootState) {
    StringBuilder buff = new StringBuilder();
    buff.append(toString());
    buff.append("" /* "").append(index.getPlan(createFilter(), rootState));
    if (selectorCondition != null) {
        buff.append("" where "").append(selectorCondition);
    }
    buff.append("" */"");
    return buff.toString();
}",0.8333333333333334,0.1650943396226413,0.0,0.0,0.6666666666666666,1.296551724137931,-0.636395552954944,2.3333333333333335,0.4,1.9457157681916588
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-579_7d72e6ed,3.0,"private Filter createFilter() {
    FilterImpl f = new FilterImpl(this, query.getStatement());
    validateNodeType(nodeTypeName);
    f.setNodeType(nodeTypeName);
    if (joinCondition != null) {
        joinCondition.restrict(f);
    }
    // ("".. is null"" must be written as ""not .. is not null"").
    if (queryConstraint != null) {
        queryConstraint.restrict(f);
    }
    return f;
}","/**
 * {@inheritDoc}
 */
","private Filter createFilter() {
    FilterImpl f = new FilterImpl(this, query.getStatement());
    validateNodeType(nodeTypeName);
    f.setNodeType(nodeTypeName);
    if (joinCondition != null) {
        joinCondition.restrict(f);
    }
        if (queryConstraint != null) {
        queryConstraint.restrict(f);
    }
    return f;
}",1.0,0.17452830188679247,0.5,0.0,1.3333333333333333,1.1793103448275861,-0.6424809830310123,0.6666666666666666,-0.23750000000000002,1.3250076040865255
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-596_9b268da0,1.0,"@Override
public MongoNode copy() {
    MongoNode copy = new MongoNode();
    copy.putAll((Map) super.copy());
    return copy;
}","/**
 * {@inheritDoc}
 */
","@Override
public MongoNode copy() {
    MongoNode copy = new MongoNode();
    copy.putAll((Map) super.copy());
    return copy;
}",0.0,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.1687536571094208,-0.3333333333333333,-0.012500000000000013,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-606_f0fbacab,1.0,"/**
 * Determine whether this item is stale
 * @return  {@code true} iff stale
 */
public boolean isStale() {
    Status status = getLocationOrNull().getStatus();
    return status == Status.DISCONNECTED || status == null;
}","/**
 * Determine whether this item is stale
 * @return  {@code true} iff stale
 */
","public boolean isStale() {
    Status status = getLocationOrNull().getStatus();
    return status == Status.DISCONNECTED || status == null;
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.9517241379310344,0.39063779988297226,-0.3333333333333333,0.85,0.5106367751516344
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-606_f0fbacab,1.0,"/**
 * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.
 * @return  tree location of the underlying item
 * @throws InvalidItemStateException if the location points to a stale item
 */
@Nonnull
public TreeLocation getLocation() throws InvalidItemStateException {
    TreeLocation location = getLocationOrNull();
    if (!location.exists()) {
        throw new InvalidItemStateException(""Item is stale"");
    }
    return location;
}","/**
 * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.
 * @return  tree location of the underlying item
 * @throws InvalidItemStateException if the location points to a stale item
 */
","@Nonnull
public TreeLocation getLocation() throws InvalidItemStateException {
    TreeLocation location = getLocationOrNull();
    if (!location.exists()) {
        throw new InvalidItemStateException(""Item is stale"");
    }
    return location;
}",0.3333333333333333,0.4952830188679243,0.5,0.0,0.6666666666666666,0.993103448275862,-0.15658279695728483,-0.3333333333333333,0.475,0.5364012094970568
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-612_df9e6913,1.0,"@Override
public Void perform() throws RepositoryException {
    // TODO: figure out the right place for this check
    NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
    // throws on not found
    NodeType nt = ntm.getNodeType(nodeTypeName);
    if (nt.isAbstract() || nt.isMixin()) {
        throw new ConstraintViolationException();
    }
    // TODO: END
    String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);
    Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);
    dlg.setProperty(jcrPrimaryType, value);
    return null;
}","/**
 * {@inheritDoc}
 */
","@Override
public Void perform() throws RepositoryException {
        NodeTypeManager ntm = sessionDelegate.getNodeTypeManager();
        NodeType nt = ntm.getNodeType(nodeTypeName);
    if (nt.isAbstract() || nt.isMixin()) {
        throw new ConstraintViolationException();
    }
        String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);
    Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);
    dlg.setProperty(jcrPrimaryType, value);
    return null;
}",1.0,0.08018867924528296,0.5,0.0,1.3333333333333333,0.8758620689655173,-0.8100643651258045,1.6666666666666667,-0.25000000000000006,1.9490078903580184
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-621_00b4b8a0,1.0,"@Override
protected synchronized NodeBuilder getNodeBuilder() {
    if (nodeBuilder == null) {
        nodeBuilder = root.createRootBuilder();
    }
    return nodeBuilder;
}","/**
 * {@inheritDoc}
 */
","@Override
protected synchronized NodeBuilder getNodeBuilder() {
    if (nodeBuilder == null) {
        nodeBuilder = root.createRootBuilder();
    }
    return nodeBuilder;
}",0.16666666666666666,0.6367924528301884,0.0,0.0,0.6666666666666666,0.8620689655172414,0.01942656524283168,-0.6666666666666666,0.23750000000000002,0.3566227120645542
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-766_6fc5ea9d,1.0,"private TreeImpl internalGetChild(String childName) {
    return nodeBuilder.hasChildNode(childName) ? new TreeImpl(root, this, childName, pendingMoves) : null;
}","/**
 * {@inheritDoc}
 */
","private TreeImpl internalGetChild(String childName) {
    return nodeBuilder.hasChildNode(childName) ? new TreeImpl(root, this, childName, pendingMoves) : null;
}",-0.5,-0.2216981132075472,0.0,-1.0,1.0,0.0,0.6424809830310116,-0.6666666666666666,-0.3875,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1.0,"/**
 * Copy this tree to the parent at {@code destParent} with the name {@code destName}.
 *
 * @param destParent  parent for the copied tree
 * @param destName  name for the copied tree
 * @return  {@code true} if successful, {@code false otherwise}. I.e.
 * when {@code destName} already exists at {@code destParent}
 */
public boolean copy(TreeImpl destParent, String destName) {
    boolean result = builder.copyTo(destParent.builder, destName);
    if (result) {
        if (listener != null) {
            listener.copy(parent, name, destParent.getChild(destName));
        }
        return true;
    }
    return result;
}","/**
 * Copy this tree to the parent at {@code destParent} with the name {@code destName}.
 *
 * @param destParent  parent for the copied tree
 * @param destName  name for the copied tree
 * @return  {@code true} if successful, {@code false otherwise}. I.e.
 * when {@code destName} already exists at {@code destParent}
 */
","public boolean copy(TreeImpl destParent, String destName) {
    boolean result = builder.copyTo(destParent.builder, destName);
    if (result) {
        if (listener != null) {
            listener.copy(parent, name, destParent.getChild(destName));
        }
        return true;
    }
    return result;
}",0.6666666666666666,1.3915094339622638,0.5,1.0,1.3333333333333333,1.103448275862069,-0.5006436512580458,0.0,-0.3500000000000001,1.2169401155821151
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1.0,"// ------------------------------------------------------------< private >---
private NodeState getNodeState() {
    return builder.getNodeState();
}","/**
 * {@inheritDoc}
 */
","private NodeState getNodeState() {
    return builder.getNodeState();
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,1.0094792276184896,-0.6666666666666666,0.85,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1.0,"@Override
public NodeState getNodeState() {
    return context.getNodeState(path);
}","/**
 * {@inheritDoc}
 */
","@Override
public NodeState getNodeState() {
    return context.getNodeState(path);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.6466939730836743,-0.6666666666666666,0.35,0.0
jackrabbit-oak,remotes/origin/bugs-dot-jar_OAK-93_0be7e8f0,1.0,"@Override
public void removeProperty(String name) {
    if (hasProperty(name)) {
        context.removeProperty(PathUtils.concat(path, name));
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void removeProperty(String name) {
    if (hasProperty(name)) {
        context.removeProperty(PathUtils.concat(path, name));
    }
}",0.0,0.8066037735849054,0.0,0.0,1.0,0.0,0.11679344645991824,0.0,-0.10000000000000003,0.0
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1.0,"/**
 * Returns the classloader that will be used for scanning for classes. If no explicit
 * ClassLoader has been set by the calling, the context class loader will be used.
 *
 * @return the ClassLoader that will be used to scan for classes
 */
public ClassLoader getClassLoader() {
    return classloader != null ? classloader : (classloader = Loader.getClassLoader(ResolverUtil.class, null));
}","/**
 * Returns the classloader that will be used for scanning for classes. If no explicit
 * ClassLoader has been set by the calling, the context class loader will be used.
 *
 * @return the ClassLoader that will be used to scan for classes
 */
","public ClassLoader getClassLoader() {
    return classloader != null ? classloader : (classloader = Loader.getClassLoader(ResolverUtil.class, null));
}",-0.5,-0.2216981132075472,0.0,-1.0,0.6666666666666666,1.0827586206896553,0.6541837331772961,-0.6666666666666666,0.65,0.4634735467248753
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1008_0c20bfd8,1.0,"/**
 * Attempts to discover classes that pass the test. Accumulated
 * classes can be accessed by calling {@link #getClasses()}.
 *
 * @param test the test to determine matching classes
 * @param packageNames one or more package names to scan (including subpackages) for classes
 */
public void find(final Test test, final String... packageNames) {
    if (packageNames == null) {
        return;
    }
    for (final String pkg : packageNames) {
        findInPackage(test, pkg);
    }
}","/**
 * Attempts to discover classes that pass the test. Accumulated
 * classes can be accessed by calling {@link #getClasses()}.
 *
 * @param test the test to determine matching classes
 * @param packageNames one or more package names to scan (including subpackages) for classes
 */
","public void find(final Test test, final String... packageNames) {
    if (packageNames == null) {
        return;
    }
    for (final String pkg : packageNames) {
        findInPackage(test, pkg);
    }
}",0.3333333333333333,0.6650943396226414,0.5,0.0,0.6666666666666666,0.0,-0.14675248683440625,-0.6666666666666666,0.42500000000000004,0.0
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-127_029e79da,1.0,"/**
 * Logs a message with the specific Marker at the FATAL level.
 *
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 */
public void fatal(Marker marker, Message msg) {
    if (isEnabled(Level.FATAL, marker, msg, null)) {
        log(null, FQCN, Level.FATAL, msg, null);
    }
}","/**
 * Logs a message with the specific Marker at the FATAL level.
 *
 * @param marker the marker data specific to this log statement
 * @param msg    the message string to be logged
 */
","public void fatal(Marker marker, Message msg) {
    if (isEnabled(Level.FATAL, marker, msg, null)) {
        log(null, FQCN, Level.FATAL, msg, null);
    }
}",-0.16666666666666666,0.8160377358490566,0.0,0.0,1.3333333333333333,0.0,0.14441193680514883,-0.3333333333333333,0.08750000000000002,0.0
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-1372_ffedf33f,3.0,"@Override
protected PrettyPrinter newPrettyPrinter() {
    return new DefaultXmlPrettyPrinter();
}","/**
 * {@inheritDoc}
 */
","@Override
protected PrettyPrinter newPrettyPrinter() {
    return new DefaultXmlPrettyPrinter();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.7548273844353419,-1.0,0.3000000000000001,0.0
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-359_1df1db27,1.0,"@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
    final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
    initializer.initialize();
    // the application is just now starting to start up
    initializer.setLoggerContext();
    servletContext.addListener(new Log4jServletContextListener());
    final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
    filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
}","/**
 * {@inheritDoc}
 */
","@Override
public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {
    servletContext.log(""Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment."");
    final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);
    initializer.initialize();
        initializer.setLoggerContext();
    servletContext.addListener(new Log4jServletContextListener());
    final FilterRegistration.Dynamic filter = servletContext.addFilter(""log4jServletFilter"", new Log4jServletFilter());
    filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, ""/*"");
}",0.6666666666666666,-0.2783018867924527,-0.5,-1.0,0.0,0.0,-0.6326506729081331,1.6666666666666667,-0.3875,0.0
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-676_3b2e880e,1.0,"@Override
protected void commitAndClose() {
    try {
        if (this.connection != null && !this.connection.isClosed()) {
            this.connection.close();
        }
    } catch (Exception e) {
        throw new AppenderLoggingException(""Failed to commit and close NoSQL connection in manager."", e);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
protected void commitAndClose() {
    try {
        if (this.connection != null && !this.connection.isClosed()) {
            this.connection.close();
        }
    } catch (Exception e) {
        throw new AppenderLoggingException(""Failed to commit and close NoSQL connection in manager."", e);
    }
}",0.6666666666666666,1.693396226415094,1.0,1.0,1.3333333333333333,0.8758620689655173,-0.39063779988297226,-0.3333333333333333,-0.25000000000000006,0.5895761392710812
logging-log4j2,remotes/origin/bugs-dot-jar_LOG4J2-813_0bea17d7,3.0,"@Override
public boolean hasParents() {
    return this.parents == null;
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean hasParents() {
    return this.parents == null;
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.6846108835576357,-1.0,0.65,0.0
maven,remotes/origin/bugs-dot-jar_MNG-3616_912a565f,1.0,"public void validate(Settings settings, SettingsProblemCollector problems) {
    List<Profile> profiles = settings.getProfiles();
    if (profiles != null) {
        for (Profile prof : profiles) {
            validateRepositories(problems, prof.getRepositories(), ""repositories.repository"");
            validateRepositories(problems, prof.getPluginRepositories(), ""pluginRepositories.pluginRepository"");
        }
    }
}","/**
 * {@inheritDoc}
 */
","public void validate(Settings settings, SettingsProblemCollector problems) {
    List<Profile> profiles = settings.getProfiles();
    if (profiles != null) {
        for (Profile prof : profiles) {
            validateRepositories(problems, prof.getRepositories(), ""repositories.repository"");
            validateRepositories(problems, prof.getPluginRepositories(), ""pluginRepositories.pluginRepository"");
        }
    }
}",0.5,2.014150943396226,0.5,1.0,0.6666666666666666,1.0551724137931036,-0.4477472205968399,0.6666666666666666,-0.3875,1.3018911810488272
wicket,remotes/origin/bugs-dot-jar_WICKET-1619_b154d12f,1.0,"/**
 *  Factory method for creating page number links.
 *
 *  @param id
 *             the component id.
 *  @param pageable
 *             the pageable for the link
 *  @param pageIndex
 *             the page index the link points to
 *  @return the page navigation link.
 */
protected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageIndex) {
    return new PagingNavigationLink<Void>(id, pageable, pageIndex) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();
        }
    };
}","/**
 *  Factory method for creating page number links.
 *
 *  @param id
 *             the component id.
 *  @param pageable
 *             the pageable for the link
 *  @param pageIndex
 *             the page index the link points to
 *  @return the page navigation link.
 */
","protected Link<?> newPagingNavigationLink(String id, IPageable pageable, int pageIndex) {
    return new PagingNavigationLink<Void>(id, pageable, pageIndex) {

        private static final long serialVersionUID = 1L;

        @Override
        public boolean isEnabled() {
            return PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();
        }
    };
}",0.5,1.5990566037735843,-0.5,0.0,0.0,0.903448275862069,-0.37378583967232276,-0.3333333333333333,0.5125000000000001,0.9008963876116012
wicket,remotes/origin/bugs-dot-jar_WICKET-1718_bb7f9cf5,1.0,"/**
 *  @see org.apache.wicket.Component#onAfterRender()
 */
@Override
protected void onAfterRender() {
    // only in development mode validate the headers
    if (getApplication().usesDevelopmentConfig()) {
        validateHeaders();
    }
    super.onAfterRender();
}","/**
 *  @see org.apache.wicket.Component#onAfterRender()
 */
","@Override
protected void onAfterRender() {
        if (getApplication().usesDevelopmentConfig()) {
        validateHeaders();
    }
    super.onAfterRender();
}",0.16666666666666666,0.6367924528301884,0.0,0.0,0.6666666666666666,0.0,0.2118197776477467,0.3333333333333333,0.6625000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1.0,"private final Component<?> children_get(int index) {
    if (index == 0) {
        if (children instanceof Component) {
            return (Component) children;
        } else {
            return ((Component[]) children)[index];
        }
    } else {
        return ((Component[]) children)[index];
    }
}","/**
 * {@inheritDoc}
 */
","private final Component<?> children_get(int index) {
    if (index == 0) {
        if (children instanceof Component) {
            return (Component) children;
        } else {
            return ((Component[]) children)[index];
        }
    } else {
        return ((Component[]) children)[index];
    }
}",0.8333333333333334,1.7216981132075468,0.5,1.0,1.3333333333333333,0.0,-0.37799882972498533,-1.0,-0.06249999999999999,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-172_99e22ce4,1.0,"/**
 *  @see wicket.Component#renderHead(wicket.markup.html.IHeaderResponse)
 */
@Override
public void renderHead(final IHeaderResponse response) {
    if (isVisible()) {
        super.renderHead(response);
        for (Component child : this) {
            child.renderHead(response);
        }
    }
}","/**
 *  @see wicket.Component#renderHead(wicket.markup.html.IHeaderResponse)
 */
","@Override
public void renderHead(final IHeaderResponse response) {
    if (isVisible()) {
        super.renderHead(response);
        for (Component child : this) {
            child.renderHead(response);
        }
    }
}",0.5,1.8820754716981127,0.5,1.0,0.6666666666666666,0.0,-0.17671152720889427,0.0,-0.012500000000000013,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-2065_9da430fb,1.0,"private void appendValue(AppendingStringBuffer url, String key, String value) {
    String escapedValue = urlEncodePathComponent(value);
    if (!Strings.isEmpty(escapedValue)) {
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(key).append(""/"").append(escapedValue).append(""/"");
    }
}","/**
 * {@inheritDoc}
 */
","private void appendValue(AppendingStringBuffer url, String key, String value) {
    String escapedValue = urlEncodePathComponent(value);
    if (!Strings.isEmpty(escapedValue)) {
        if (!url.endsWith(""/"")) {
            url.append(""/"");
        }
        url.append(key).append(""/"").append(escapedValue).append(""/"");
    }
}",0.5,1.55188679245283,0.5,1.0,1.6666666666666667,1.4758620689655173,-0.47349327091866605,1.6666666666666667,-0.3625000000000001,2.0243688608183787
wicket,remotes/origin/bugs-dot-jar_WICKET-2065_9da430fb,1.0,"/**
 *  @see java.lang.Object#toString()
 */
public String toString() {
    return ""PackageEncoder[package="" + packageName + ""]"";
}","/**
 *  @see java.lang.Object#toString()
 */
","public String toString() {
    return ""PackageEncoder[package="" + packageName + ""]"";
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8451726155646576,-1.0,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-208_b224bad8,3.0,"/**
 *  @param updateInterval
 *             Duration between AJAX callbacks
 *  @return JS script
 */
protected final String getJsTimeoutCall(final Duration updateInterval) {
    return ""setTimeout(function() { "" + getCallbackScript(false, true) + "" }, "" + updateInterval.getMilliseconds() + "");"";
}","/**
 *  @param updateInterval
 *             Duration between AJAX callbacks
 *  @return JS script
 */
","protected final String getJsTimeoutCall(final Duration updateInterval) {
    return ""setTimeout(function() { "" + getCallbackScript(false, true) + "" }, "" + updateInterval.getMilliseconds() + "");"";
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.6092451726155637,-0.3333333333333333,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-2172_ea4a3f8a,3.0,"/**
 *  @see IValueMap#getAsEnum
 */
public <T extends Enum<T>> T getAsEnum(String key, T defaultValue) {
    if (defaultValue == null)
        throw new IllegalArgumentException(""Default value cannot be null"");
    return getEnumImpl(key, defaultValue.getClass(), defaultValue);
}","/**
 *  @see IValueMap#getAsEnum
 */
","public <T extends Enum<T>> T getAsEnum(String key, T defaultValue) {
    if (defaultValue == null)
        throw new IllegalArgumentException(""Default value cannot be null"");
    return getEnumImpl(key, defaultValue.getClass(), defaultValue);
}",-0.16666666666666666,0.8160377358490566,0.5,-1.0,0.6666666666666666,0.0,0.11351667641895827,-0.3333333333333333,0.4875,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-2337_36a41358,1.0,"/**
 *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)
 */
public Object getValue(Object object) {
    return ((List<?>) object).get(index);
}","/**
 *  @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)
 */
","public Object getValue(Object object) {
    return ((List<?>) object).get(index);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7838502047981274,-0.6666666666666666,0.2875000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-2506_0f8a2990,1.0,"private void restoreOriginalChildVisibility() {
    if (changes != null) {
        MarkupContainer container = getEnclosureParent();
        // restore original visibility statuses
        for (Map.Entry<Component, Boolean> entry : changes.entrySet()) {
            entry.getKey().setVisibilityAllowed(entry.getValue());
        }
        changes = null;
    }
}","/**
 * {@inheritDoc}
 */
","private void restoreOriginalChildVisibility() {
    if (changes != null) {
        MarkupContainer container = getEnclosureParent();
                for (Map.Entry<Component, Boolean> entry : changes.entrySet()) {
            entry.getKey().setVisibilityAllowed(entry.getValue());
        }
        changes = null;
    }
}",0.5,1.5990566037735843,0.5,1.0,0.6666666666666666,0.903448275862069,-0.4060854300760675,0.6666666666666666,-0.03750000000000003,0.9400440142420068
wicket,remotes/origin/bugs-dot-jar_WICKET-2621_c849f986,1.0,"/**
 *  Set to true to use enctype='multipart/form-data', and to process file uploads by default
 *  multiPart = false
 *
 *  @param multiPart
 *             whether this form should behave as a multipart form
 */
public void setMultiPart(boolean multiPart) {
    this.multiPart = multiPart;
}","/**
 *  Set to true to use enctype='multipart/form-data', and to process file uploads by default
 *  multiPart = false
 *
 *  @param multiPart
 *             whether this form should behave as a multipart form
 */
","public void setMultiPart(boolean multiPart) {
    this.multiPart = multiPart;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9650087770626097,-1.0,0.825,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-2621_c849f986,1.0,"@Override
public void onFormComponent(FormComponent<?> formComponent) {
    if (formComponent.isVisible() && formComponent.isMultiPart()) {
        setMultiPart(true);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void onFormComponent(FormComponent<?> formComponent) {
    if (formComponent.isVisible() && formComponent.isMultiPart()) {
        setMultiPart(true);
    }
}",0.0,0.8066037735849054,0.0,0.0,1.3333333333333333,0.0,0.1364540667056754,0.0,-0.3875,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-3280_295e73bd,1.0,"/**
 *  @param response
 */
private void fireOnAfterRespondListeners(final WebResponse response) {
    // invoke onafterresponse event on listeners
    if (listeners != null) {
        final Map<String, Component> components = Collections.unmodifiableMap(markupIdToComponent);
        // create response that will be used by listeners to append
        // javascript
        final IJavaScriptResponse jsresponse = new IJavaScriptResponse() {

            public void addJavaScript(String script) {
                respondInvocation(response, script);
            }
        };
        for (IListener listener : listeners) {
            listener.onAfterRespond(components, jsresponse);
        }
    }
}","/**
 *  @param response
 */
","private void fireOnAfterRespondListeners(final WebResponse response) {
        if (listeners != null) {
        final Map<String, Component> components = Collections.unmodifiableMap(markupIdToComponent);
                        final IJavaScriptResponse jsresponse = new IJavaScriptResponse() {

            public void addJavaScript(String script) {
                respondInvocation(response, script);
            }
        };
        for (IListener listener : listeners) {
            listener.onAfterRespond(components, jsresponse);
        }
    }
}",1.1666666666666667,2.297169811320754,0.5,1.0,0.6666666666666666,0.9517241379310344,-0.7744880046810997,0.0,0.3000000000000001,1.4306417849027573
wicket,remotes/origin/bugs-dot-jar_WICKET-3510_292a2582,1.0,"/**
 *  Creates a new DateTextField defaulting to using a short date pattern
 *
 *  @param id
 *             The id of the text field
 *  @return DateTextField
 */
public static DateTextField forShortStyle(String id) {
    return forShortStyle(id, null);
}","/**
 *  Creates a new DateTextField defaulting to using a short date pattern
 *
 *  @param id
 *             The id of the text field
 *  @return DateTextField
 */
","public static DateTextField forShortStyle(String id) {
    return forShortStyle(id, null);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.83253364540667,-0.6666666666666666,0.8375,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-3647_1b57b51c,1.0,"/**
 *  Get the markupId
 *
 *  @return MarkupId
 */
public final Object getMarkupIdImpl() {
    String id = getMarkupIdFromMarkup();
    if (id != null) {
        return id;
    }
    if (generatedMarkupId != -1) {
        return generatedMarkupId;
    }
    return getMetaData(MARKUP_ID_KEY);
}","/**
 *  Get the markupId
 *
 *  @return MarkupId
 */
","public final Object getMarkupIdImpl() {
    String id = getMarkupIdFromMarkup();
    if (id != null) {
        return id;
    }
    if (generatedMarkupId != -1) {
        return generatedMarkupId;
    }
    return getMetaData(MARKUP_ID_KEY);
}",0.6666666666666666,0.3820754716981129,0.5,0.0,1.3333333333333333,0.8758620689655173,-0.3934464599180806,-0.3333333333333333,0.8125,0.624214989891038
wicket,remotes/origin/bugs-dot-jar_WICKET-4000_38e928c1,1.0,"@Override
public void component(final Component component, final IVisit<Void> visit) {
    component.renderHead(headerContainer);
}","/**
 * {@inheritDoc}
 */
","@Override
public void component(final Component component, final IVisit<Void> visit) {
    component.renderHead(headerContainer);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.48706846108835555,-0.6666666666666666,-0.225,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4038_f3d7565c,1.0,"/**
 *  Cleans the original parameters from entries used by Wicket internals.
 *
 *  @param originalParameters
 *             the current request's non-modified parameters
 *  @return all parameters but Wicket internal ones
 */
private PageParameters cleanPageParameters(final PageParameters originalParameters) {
    PageParameters cleanParameters = new PageParameters(originalParameters);
    // WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.
    // They shouldn't be propagated to the next requests
    cleanParameters.remove(WebRequest.PARAM_AJAX);
    cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);
    return cleanParameters;
}","/**
 *  Cleans the original parameters from entries used by Wicket internals.
 *
 *  @param originalParameters
 *             the current request's non-modified parameters
 *  @return all parameters but Wicket internal ones
 */
","private PageParameters cleanPageParameters(final PageParameters originalParameters) {
    PageParameters cleanParameters = new PageParameters(originalParameters);
            cleanParameters.remove(WebRequest.PARAM_AJAX);
    cleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);
    return cleanParameters;
}",0.0,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.03534230544177858,-0.3333333333333333,0.6125000000000002,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645,1.0,"/**
 *  Parses the given URL string.
 *
 *  @param url
 *            absolute or relative url with query string
 *  @return Url object
 */
public static Url parse(final String url) {
    return parse(url, null);
}","/**
 *  Parses the given URL string.
 *
 *  @param url
 *            absolute or relative url with query string
 *  @return Url object
 */
","public static Url parse(final String url) {
    return parse(url, null);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.83253364540667,-0.6666666666666666,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4072_7d5b8645,1.0,"/**
 *  return query string part of url in given encoding
 *
 *  @param charset
 *           character set for encoding
 *
 *  @return query string
 */
public String getQueryString(Charset charset) {
    Args.notNull(charset, ""charset"");
    StringBuilder query = new StringBuilder();
    for (QueryParameter parameter : getQueryParameters()) {
        query.append(query.length() == 0 ? '?' : '&');
        query.append(parameter.toString(charset));
    }
    return query.toString();
}","/**
 *  return query string part of url in given encoding
 *
 *  @param charset
 *           character set for encoding
 *
 *  @return query string
 */
","public String getQueryString(Charset charset) {
    Args.notNull(charset, ""charset"");
    StringBuilder query = new StringBuilder();
    for (QueryParameter parameter : getQueryParameters()) {
        query.append(query.length() == 0 ? '?' : '&');
        query.append(parameter.toString(charset));
    }
    return query.toString();
}",0.5,0.5141509433962262,0.5,0.0,0.6666666666666666,1.110344827586207,-0.4767700409596254,1.3333333333333333,0.12499999999999999,1.5448641105007963
wicket,remotes/origin/bugs-dot-jar_WICKET-4105_64656c98,1.0,"/**
 *  Create a new response object which is used to store the markup generated by the child
 *  objects.
 *
 *  @param originalResponse
 *
 *  @return Response object. Must not be null
 */
protected BufferedWebResponse newResponse(final WebResponse originalResponse) {
    return new BufferedWebResponse(originalResponse);
}","/**
 *  Create a new response object which is used to store the markup generated by the child
 *  objects.
 *
 *  @param originalResponse
 *
 *  @return Response object. Must not be null
 */
","protected BufferedWebResponse newResponse(final WebResponse originalResponse) {
    return new BufferedWebResponse(originalResponse);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.8910473961380918,-1.0,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4173_84bbbf68,1.0,"/**
 *  Convenience method for setting next page to be rendered.
 *
 *  @param pageClass
 */
public void setResponsePage(Class<? extends IRequestablePage> pageClass) {
    IPageProvider provider = new PageProvider(pageClass, null);
    scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider, RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));
}","/**
 *  Convenience method for setting next page to be rendered.
 *
 *  @param pageClass
 */
","public void setResponsePage(Class<? extends IRequestablePage> pageClass) {
    IPageProvider provider = new PageProvider(pageClass, null);
    scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider, RenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.3368051492100639,-0.6666666666666666,0.6625000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3.0,"/**
 *  @see java.util.Map#values()
 */
public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            return value;
        }

        public int size() {
            return MicroMap.this.size();
        }
    };
}","/**
 *  @see java.util.Map#values()
 */
","public Collection values() {
    return new AbstractList() {

        public Object get(final int index) {
            return value;
        }

        public int size() {
            return MicroMap.this.size();
        }
    };
}",0.6666666666666666,1.844339622641509,-0.5,0.0,0.0,0.0,-0.2188414277355176,-0.6666666666666666,0.8125,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-428_d906576c,3.0,"public Object get(final int index) {
    return value;
}","/**
 * {@inheritDoc}
 */
","public Object get(final int index) {
    return value;
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.9729666471620824,-1.0,0.7749999999999999,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1.0,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Character toOptionalCharacter() throws StringValueConversionException {
    return (text == null) ? null : toCharacter();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Character toOptionalCharacter() throws StringValueConversionException {
    return (text == null) ? null : toCharacter();
}",-0.5,-0.2216981132075472,0.0,-1.0,0.6666666666666666,0.0,0.7566998244587471,-0.6666666666666666,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4309_b4274415,1.0,"/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
public final Duration toOptionalDuration() throws StringValueConversionException {
    return (text == null) ? null : toDuration();
}","/**
 *  Convert to object types, returning null if text is null.
 *
 *  @return converted
 *  @throws StringValueConversionException
 */
","public final Duration toOptionalDuration() throws StringValueConversionException {
    return (text == null) ? null : toDuration();
}",-0.5,-0.2216981132075472,0.0,-1.0,0.6666666666666666,0.0,0.7566998244587471,-0.6666666666666666,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4338_9decad35,3.0,"/**
 *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()
 */
public Set<String> getParameterNames() {
    Set<String> result = new HashSet<String>();
    for (IRequestParameters p : parameters) {
        result.addAll(p.getParameterNames());
    }
    return Collections.unmodifiableSet(result);
}","/**
 *  @see org.apache.wicket.request.IRequestParameters#getParameterNames()
 */
","public Set<String> getParameterNames() {
    Set<String> result = new HashSet<String>();
    for (IRequestParameters p : parameters) {
        result.addAll(p.getParameterNames());
    }
    return Collections.unmodifiableSet(result);
}",0.16666666666666666,0.410377358490566,0.0,0.0,0.0,0.0,-0.13130485664131095,0.0,-0.06249999999999999,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4391_5d64196a,3.0,"@Override
public MarkupType getMarkupType() {
    return new MarkupType(""xsl"", null);
}","/**
 * {@inheritDoc}
 */
","@Override
public MarkupType getMarkupType() {
    return new MarkupType(""xsl"", null);
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.6466939730836743,-1.0,0.23750000000000002,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1.0,"/**
 *  Registers an informational feedback message for this component
 *
 *  @param message
 *             The feedback message
 */
public final void info(final String message) {
    getPage().getFeedbackMessages().info(this, message);
}","/**
 *  Registers an informational feedback message for this component
 *
 *  @param message
 *             The feedback message
 */
","public final void info(final String message) {
    getPage().getFeedbackMessages().info(this, message);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.83253364540667,0.0,0.7999999999999999,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1.0,"/**
 *  This returns a page instance that is rollbacked the number of versions
 *  that is specified compared to the current page.
 *
 *  This is a rollback including ajax versions.
 *
 *  @param numberOfVersions to rollback
 *  @return
 */
public final Page rollbackPage(int numberOfVersions) {
    Page page = versionManager == null ? this : versionManager.rollbackPage(numberOfVersions);
    getSession().touch(page);
    return page;
}","/**
 *  This returns a page instance that is rollbacked the number of versions
 *  that is specified compared to the current page.
 *
 *  This is a rollback including ajax versions.
 *
 *  @param numberOfVersions to rollback
 *  @return
 */
","public final Page rollbackPage(int numberOfVersions) {
    Page page = versionManager == null ? this : versionManager.rollbackPage(numberOfVersions);
    getSession().touch(page);
    return page;
}",-0.16666666666666666,-0.15566037735849056,0.0,-1.0,0.6666666666666666,1.1517241379310346,0.17998829724985357,0.0,0.8375,0.701508292927305
wicket,remotes/origin/bugs-dot-jar_WICKET-442_246d53c5,1.0,"/**
 *  Removes any rendered feedback messages as well as compacts memory. This
 *  method is usually called at the end of the request cycle processing.
 */
final void cleanupFeedbackMessages() {
    int size = feedbackMessages.size();
    feedbackMessages.clearRendered();
    // the session is dirty when the list of feedback messages was changed
    if (size != feedbackMessages.size()) {
        dirty();
    }
}","/**
 *  Removes any rendered feedback messages as well as compacts memory. This
 *  method is usually called at the end of the request cycle processing.
 */
","final void cleanupFeedbackMessages() {
    int size = feedbackMessages.size();
    feedbackMessages.clearRendered();
        if (size != feedbackMessages.size()) {
        dirty();
    }
}",0.16666666666666666,0.410377358490566,0.0,0.0,1.0,1.2620689655172415,0.025043885313048395,0.3333333333333333,0.625,0.5117102932493603
wicket,remotes/origin/bugs-dot-jar_WICKET-4509_b672cb2d,1.0,"/**
 *  for urls that point to local files (e.g. 'file:' or 'jar:file:') this methods returns a
 *  reference to the local file
 *
 *  @param url
 *             url of the resource
 *
 *  @return reference to a local file if url contains one, <code>null</code> otherwise
 *
 *  @see #getLocalFileFromUrl(String)
 */
public static File getLocalFileFromUrl(URL url) {
    return getLocalFileFromUrl(Args.notNull(url, ""url"").toExternalForm());
}","/**
 *  for urls that point to local files (e.g. 'file:' or 'jar:file:') this methods returns a
 *  reference to the local file
 *
 *  @param url
 *             url of the resource
 *
 *  @return reference to a local file if url contains one, <code>null</code> otherwise
 *
 *  @see #getLocalFileFromUrl(String)
 */
","public static File getLocalFileFromUrl(URL url) {
    return getLocalFileFromUrl(Args.notNull(url, ""url"").toExternalForm());
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7187829139847856,0.0,0.7999999999999999,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4520_ccb8fc9e,1.0,"@Override
public Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {
    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);
    if (Strings.isEmpty(inlineEnclosureChildId) == false) {
        String id = tag.getId();
        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {
            id = id + container.getPage().getAutoIndex();
        }
        // Yes, we handled the tag
        return new InlineEnclosure(id, inlineEnclosureChildId);
    }
    // We were not able to handle the tag
    return null;
}","/**
 * {@inheritDoc}
 */
","@Override
public Component resolve(final MarkupContainer container, final MarkupStream markupStream, final ComponentTag tag) {
    String inlineEnclosureChildId = getInlineEnclosureAttribute(tag);
    if (Strings.isEmpty(inlineEnclosureChildId) == false) {
        String id = tag.getId();
        if (id.equals(INLINE_ENCLOSURE_ID_PREFIX)) {
            id = id + container.getPage().getAutoIndex();
        }
                return new InlineEnclosure(id, inlineEnclosureChildId);
    }
        return null;
}",1.0,1.4858490566037734,0.5,1.0,1.6666666666666667,0.9793103448275862,-0.7740198946752481,1.0,-0.21250000000000002,1.8801595963571953
wicket,remotes/origin/bugs-dot-jar_WICKET-4616_dd1df04b,1.0,"/**
 *  Called (by the default implementation of 'process') when all fields validated, the form was
 *  updated and it's data was allowed to be persisted. It is meant for delegating further
 *  processing to clients.
 *  <p>
 *  This implementation first finds out whether the form processing was triggered by a nested
 *  IFormSubmittingComponent of this form. If that is the case, that component's onSubmit is
 *  called first.
 *  </p>
 *  <p>
 *  Regardless of whether a submitting component was found, the form's onSubmit method is called
 *  next.
 *  </p>
 *
 *  @param submittingComponent
 *             the component that triggered this form processing, or null if the processing was
 *             triggered by something else (like a non-Wicket submit button or a javascript
 *             execution)
 */
protected void delegateSubmit(IFormSubmitter submittingComponent) {
    final Form<?> processingForm = findFormToProcess(submittingComponent);
    // process submitting component (if specified)
    if (submittingComponent != null) {
        // invoke submit on component
        submittingComponent.onSubmitBeforeForm();
    }
    // invoke Form#onSubmit(..) going from innermost to outermost
    Visits.visitPostOrder(processingForm, new IVisitor<Form<?>, Void>() {

        @Override
        public void component(Form<?> form, IVisit<Void> visit) {
            if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()) {
                form.onSubmit();
            }
        }
    }, new ClassVisitFilter(Form.class));
    if (submittingComponent != null) {
        submittingComponent.onSubmitAfterForm();
    }
}","/**
 *  Called (by the default implementation of 'process') when all fields validated, the form was
 *  updated and it's data was allowed to be persisted. It is meant for delegating further
 *  processing to clients.
 *  <p>
 *  This implementation first finds out whether the form processing was triggered by a nested
 *  IFormSubmittingComponent of this form. If that is the case, that component's onSubmit is
 *  called first.
 *  </p>
 *  <p>
 *  Regardless of whether a submitting component was found, the form's onSubmit method is called
 *  next.
 *  </p>
 *
 *  @param submittingComponent
 *             the component that triggered this form processing, or null if the processing was
 *             triggered by something else (like a non-Wicket submit button or a javascript
 *             execution)
 */
","protected void delegateSubmit(IFormSubmitter submittingComponent) {
    final Form<?> processingForm = findFormToProcess(submittingComponent);
        if (submittingComponent != null) {
                submittingComponent.onSubmitBeforeForm();
    }
        Visits.visitPostOrder(processingForm, new IVisitor<Form<?>, Void>() {

        @Override
        public void component(Form<?> form, IVisit<Void> visit) {
            if (form.isEnabledInHierarchy() && form.isVisibleInHierarchy()) {
                form.onSubmit();
            }
        }
    }, new ClassVisitFilter(Form.class));
    if (submittingComponent != null) {
        submittingComponent.onSubmitAfterForm();
    }
}",1.8333333333333333,1.8915094339622636,1.0,1.0,2.3333333333333335,1.110344827586207,-1.0586307782328845,1.3333333333333333,-0.4,2.218747204379954
wicket,remotes/origin/bugs-dot-jar_WICKET-4658_ef3adb12,3.0,"@Override
public boolean isVisible() {
    return getTabs().get(tabIndex).isVisible();
}","/**
 * {@inheritDoc}
 */
","@Override
public boolean isVisible() {
    return getTabs().get(tabIndex).isVisible();
}",-0.3333333333333333,-0.3726415094339622,-0.5,-1.0,0.0,0.0,0.6466939730836743,0.0,0.2750000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4659_ccd74641,1.0,"@Override
public IRequestHandler map(Exception e) {
    try {
        return internalMap(e);
    } catch (RuntimeException e2) {
        if (logger.isDebugEnabled()) {
            logger.error(""An error occurred while handling a previous error: "" + e2.getMessage(), e2);
        }
        // hmmm, we were already handling an exception! give up
        logger.error(""unexpected exception when handling another exception: "" + e.getMessage(), e);
        return new ErrorCodeRequestHandler(500);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public IRequestHandler map(Exception e) {
    try {
        return internalMap(e);
    } catch (RuntimeException e2) {
        if (logger.isDebugEnabled()) {
            logger.error(""An error occurred while handling a previous error: "" + e2.getMessage(), e2);
        }
                logger.error(""unexpected exception when handling another exception: "" + e.getMessage(), e);
        return new ErrorCodeRequestHandler(500);
    }
}",1.0,1.55188679245283,0.5,1.0,0.6666666666666666,0.0,-0.6616734932709185,1.0,-0.375,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4766_cda34428,1.0,"/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.
 *
 *  Temporarily replaces the response with a StringResponse to capture the header output for this
 *  part of the stream and pass it to {@link IHeaderResponse}.
 *
 *  @see org.apache.wicket.MarkupContainer#renderNext(org.apache.wicket.markup.MarkupStream)
 */
@Override
protected final boolean renderNext(MarkupStream markupStream) {
    StringResponse markupHeaderResponse = new StringResponse();
    Response oldResponse = getResponse();
    RequestCycle.get().setResponse(markupHeaderResponse);
    try {
        boolean ret = super.renderNext(markupStream);
        getHeaderResponse().render(new PageHeaderItem(markupHeaderResponse.getBuffer()));
        return ret;
    } finally {
        RequestCycle.get().setResponse(oldResponse);
    }
}","/**
 *  THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.
 *
 *  Temporarily replaces the response with a StringResponse to capture the header output for this
 *  part of the stream and pass it to {@link IHeaderResponse}.
 *
 *  @see org.apache.wicket.MarkupContainer#renderNext(org.apache.wicket.markup.MarkupStream)
 */
","@Override
protected final boolean renderNext(MarkupStream markupStream) {
    StringResponse markupHeaderResponse = new StringResponse();
    Response oldResponse = getResponse();
    RequestCycle.get().setResponse(markupHeaderResponse);
    try {
        boolean ret = super.renderNext(markupStream);
        getHeaderResponse().render(new PageHeaderItem(markupHeaderResponse.getBuffer()));
        return ret;
    } finally {
        RequestCycle.get().setResponse(oldResponse);
    }
}",1.1666666666666667,0.7499999999999998,-0.5,0.0,0.0,0.0,-0.730017554125219,2.0,-0.3,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1.0,"private void checkHeader() {
    if (bufferedWritten) {
        throw new IllegalStateException(""Header was already written to response!"");
    }
}","/**
 * {@inheritDoc}
 */
","private void checkHeader() {
    if (bufferedWritten) {
        throw new IllegalStateException(""Header was already written to response!"");
    }
}",-0.16666666666666666,0.8160377358490566,0.5,0.0,0.6666666666666666,0.0,0.5643066120538327,-1.0,0.6875000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1.0,"@Override
public void clearCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.clearCookie(cookie);
}","/**
 * {@inheritDoc}
 */
","@Override
public void clearCookie(Cookie cookie) {
    checkHeader();
    bufferedResponse.clearCookie(cookie);
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.39625511995318896,-0.3333333333333333,0.31249999999999994,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1.0,"@Override
public void addHeader(String name, String value) {
    checkHeader();
    bufferedResponse.addHeader(name, value);
}","/**
 * {@inheritDoc}
 */
","@Override
public void addHeader(String name, String value) {
    checkHeader();
    bufferedResponse.addHeader(name, value);
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.31012287887653583,-0.3333333333333333,-0.17500000000000004,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-4927_8c827e33,1.0,"@Override
public void write(CharSequence sequence) {
    writeBuffered();
    originalResponse.write(sequence);
}","/**
 * {@inheritDoc}
 */
","@Override
public void write(CharSequence sequence) {
    writeBuffered();
    originalResponse.write(sequence);
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.39625511995318896,-0.3333333333333333,0.2750000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_6e794ad0,1.0,"/**
 *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)
 */
@Override
public int getCompatibilityScore(Request request) {
    int score = 0;
    Url url = request.getUrl();
    if (matches(url)) {
        score = Integer.MAX_VALUE;
    }
    return score;
}","/**
 *  @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)
 */
","@Override
public int getCompatibilityScore(Request request) {
    int score = 0;
    Url url = request.getUrl();
    if (matches(url)) {
        score = Integer.MAX_VALUE;
    }
    return score;
}",0.5,0.363207547169811,0.0,0.0,1.0,0.0,-0.32837916910473947,-0.3333333333333333,0.5750000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5071_6e794ad0,1.0,"private boolean matches(final Url url) {
    return (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier()));
}","/**
 * {@inheritDoc}
 */
","private boolean matches(final Url url) {
    return (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(), getContext().getBookmarkableIdentifier()));
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.8758620689655173,0.576477472205968,1.3333333333333333,-0.4,0.5392639244243259
wicket,remotes/origin/bugs-dot-jar_WICKET-5082_217fbb3b,1.0,"@Override
public void renderHead(final Component component, final IHeaderResponse response) {
    super.renderHead(component, response);
    if (component.isEnabledInHierarchy()) {
        CharSequence js = getCallbackScript(component);
        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);
        if (target == null) {
            response.render(OnDomReadyHeaderItem.forScript(js.toString()));
        } else {
            target.appendJavaScript(js);
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void renderHead(final Component component, final IHeaderResponse response) {
    super.renderHead(component, response);
    if (component.isEnabledInHierarchy()) {
        CharSequence js = getCallbackScript(component);
        AjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);
        if (target == null) {
            response.render(OnDomReadyHeaderItem.forScript(js.toString()));
        } else {
            target.appendJavaScript(js);
        }
    }
}",1.1666666666666667,1.8066037735849052,0.5,1.0,1.3333333333333333,1.0827586206896553,-0.8030427150380336,2.0,-0.3875,1.831421874720438
wicket,remotes/origin/bugs-dot-jar_WICKET-5147_184e51e9,1.0,"@Override
public IRequestHandler map(Exception e) {
    try {
        Response response = RequestCycle.get().getResponse();
        if (response instanceof WebResponse) {
            // we don't wan't to cache an exceptional reply in the browser
            ((WebResponse) response).disableCaching();
        }
        return internalMap(e);
    } catch (RuntimeException e2) {
        if (logger.isDebugEnabled()) {
            logger.error(""An error occurred while handling a previous error: "" + e2.getMessage(), e2);
        }
        // hmmm, we were already handling an exception! give up
        logger.error(""unexpected exception when handling another exception: "" + e.getMessage(), e);
        return new ErrorCodeRequestHandler(500);
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public IRequestHandler map(Exception e) {
    try {
        Response response = RequestCycle.get().getResponse();
        if (response instanceof WebResponse) {
                        ((WebResponse) response).disableCaching();
        }
        return internalMap(e);
    } catch (RuntimeException e2) {
        if (logger.isDebugEnabled()) {
            logger.error(""An error occurred while handling a previous error: "" + e2.getMessage(), e2);
        }
                logger.error(""unexpected exception when handling another exception: "" + e.getMessage(), e);
        return new ErrorCodeRequestHandler(500);
    }
}",1.6666666666666667,1.514150943396226,1.0,1.0,1.3333333333333333,1.0344827586206897,-1.0001170275014628,2.0,-0.3875,1.9679733767511767
wicket,remotes/origin/bugs-dot-jar_WICKET-5209_55eb5212,1.0,"/**
 *  Collects the html generated by the rendering of a component.
 *
 *  @param component
 *             the component to render.
 *  @return the html rendered by the component
 */
public static CharSequence renderComponent(final Component component) {
    RequestCycle requestCycle = RequestCycle.get();
    final Response originalResponse = requestCycle.getResponse();
    BufferedWebResponse tempResponse = new BufferedWebResponse(null);
    try {
        requestCycle.setResponse(tempResponse);
        RenderPage page = new RenderPage();
        page.add(component);
        component.render();
    } finally {
        requestCycle.setResponse(originalResponse);
    }
    return tempResponse.getText();
}","/**
 *  Collects the html generated by the rendering of a component.
 *
 *  @param component
 *             the component to render.
 *  @return the html rendered by the component
 */
","public static CharSequence renderComponent(final Component component) {
    RequestCycle requestCycle = RequestCycle.get();
    final Response originalResponse = requestCycle.getResponse();
    BufferedWebResponse tempResponse = new BufferedWebResponse(null);
    try {
        requestCycle.setResponse(tempResponse);
        RenderPage page = new RenderPage();
        page.add(component);
        component.render();
    } finally {
        requestCycle.setResponse(originalResponse);
    }
    return tempResponse.getText();
}",1.3333333333333333,0.5424528301886793,-0.5,0.0,0.0,0.0,-0.8372147454651842,1.3333333333333333,-0.3625000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5326_ded3c583,1.0,"@Override
public Url mapHandler(final IRequestHandler requestHandler) {
    final Url url = wrappedMapper.mapHandler(requestHandler);
    if (url == null) {
        return null;
    }
    if (url.isFull()) {
        // do not encrypt full urls
        return url;
    }
    return encryptUrl(url);
}","/**
 * {@inheritDoc}
 */
","@Override
public Url mapHandler(final IRequestHandler requestHandler) {
    final Url url = wrappedMapper.mapHandler(requestHandler);
    if (url == null) {
        return null;
    }
    if (url.isFull()) {
                return url;
    }
    return encryptUrl(url);
}",0.8333333333333334,0.5141509433962262,0.5,0.0,1.3333333333333333,1.193103448275862,-0.4964306612053832,0.0,0.10000000000000003,0.9606555617183447
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3.0,"/**
 *  Convert this text to an enum.
 *
 *  @param eClass
 *             enum type
 *  @return The value as an enum
 *  @throws StringValueConversionException
 */
public final <T extends Enum<T>> T toEnum(Class<T> eClass) throws StringValueConversionException {
    return Strings.toEnum(text, eClass);
}","/**
 *  Convert this text to an enum.
 *
 *  @param eClass
 *             enum type
 *  @return The value as an enum
 *  @throws StringValueConversionException
 */
","public final <T extends Enum<T>> T toEnum(Class<T> eClass) throws StringValueConversionException {
    return Strings.toEnum(text, eClass);
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.6466939730836743,-0.6666666666666666,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5359_61122bab,3.0,"/**
 *  Convert this text to an enum.
 *
 *  @param defaultValue
 *             This will be returned if there is an error converting the value
 *  @return The value as an enum
 */
public final <T extends Enum<T>> T toEnum(final T defaultValue) {
    Args.notNull(defaultValue, ""defaultValue"");
    return toEnum((Class<T>) defaultValue.getClass(), defaultValue);
}","/**
 *  Convert this text to an enum.
 *
 *  @param defaultValue
 *             This will be returned if there is an error converting the value
 *  @return The value as an enum
 */
","public final <T extends Enum<T>> T toEnum(final T defaultValue) {
    Args.notNull(defaultValue, ""defaultValue"");
    return toEnum((Class<T>) defaultValue.getClass(), defaultValue);
}",-0.3333333333333333,-0.11792452830188677,-0.5,-1.0,0.0,0.0,0.3672322995904035,0.0,0.6875000000000001,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5418_e350f19e,1.0,"@Override
public void onConfigure(Component component) {
    super.onConfigure(component);
    if (requiredFlagSet == false) {
        // ""Required"" flag is calculated upon component's model property, so we must ensure,
        // that model object is accessible (i.e. component is already added in a page).
        requiredFlagSet = true;
        setComponentRequiredFlag();
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void onConfigure(Component component) {
    super.onConfigure(component);
    if (requiredFlagSet == false) {
                        requiredFlagSet = true;
        setComponentRequiredFlag();
    }
}",0.3333333333333333,0.9386792452830187,0.0,0.0,0.6666666666666666,0.9172413793103449,-0.12896430661205355,-0.3333333333333333,0.10000000000000003,0.4621853250076041
wicket,remotes/origin/bugs-dot-jar_WICKET-5447_2abc18f1,3.0,"@Override
public void afterRender(Component component) {
    Response response = component.getResponse();
    for (int i = 0; i < branches.length; i++) {
        response.write(""</div>"");
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void afterRender(Component component) {
    Response response = component.getResponse();
    for (int i = 0; i < branches.length; i++) {
        response.write(""</div>"");
    }
}",0.16666666666666666,0.6367924528301884,0.0,0.0,1.0,0.8896551724137931,-0.17858396723229938,-0.3333333333333333,-0.10000000000000003,0.8274677497271475
wicket,remotes/origin/bugs-dot-jar_WICKET-5460_a3a5a40f,1.0,"/**
 *  @param setRenderingFlag
 *             rendering flag
 */
void internalMarkRendering(boolean setRenderingFlag) {
    if (setRenderingFlag) {
        setFlag(FLAG_PREPARED_FOR_RENDER, false);
        setFlag(FLAG_RENDERING, true);
    } else {
        setFlag(FLAG_RENDERING, false);
    }
}","/**
 *  @param setRenderingFlag
 *             rendering flag
 */
","void internalMarkRendering(boolean setRenderingFlag) {
    if (setRenderingFlag) {
        setFlag(FLAG_PREPARED_FOR_RENDER, false);
        setFlag(FLAG_RENDERING, true);
    } else {
        setFlag(FLAG_RENDERING, false);
    }
}",0.3333333333333333,0.9386792452830187,0.0,0.0,0.6666666666666666,0.0,-0.07653598595670003,0.0,0.7250000000000002,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5570_57d8f051,1.0,"/**
 *  @return the name of the handle that is used to stop any scheduled timer
 */
private String getTimeoutHandle() {
    return ""Wicket.TimerHandles['"" + getComponent().getMarkupId() + ""']"";
}","/**
 *  @return the name of the handle that is used to stop any scheduled timer
 */
","private String getTimeoutHandle() {
    return ""Wicket.TimerHandles['"" + getComponent().getMarkupId() + ""']"";
}",-0.5,-0.2216981132075472,-0.5,-1.0,0.0,0.0,0.7964891749561136,-0.3333333333333333,0.85,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5582_1fb66533,1.0,"@Override
public String encodeURL(CharSequence url) {
    Args.notNull(url, ""url"");
    /*
		  WICKET-4645 - always pass absolute url to the web container for encoding
		  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when
		  PageA is actually the requested one and the web container cannot resolve
		  the base url properly
		 */
    UrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();
    Url relativeUrl = Url.parse(url);
    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);
    String encodedFullUrl = httpServletResponse.encodeURL(fullUrl);
    final String encodedRelativeUrl;
    if (fullUrl.equals(encodedFullUrl)) {
        // no encoding happened so just reuse the relative url
        encodedRelativeUrl = url.toString();
    } else {
        // get the relative url with the jsessionid encoded in it
        Url _encoded = Url.parse(encodedFullUrl);
        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);
    }
    return encodedRelativeUrl;
}","/**
 * {@inheritDoc}
 */
","@Override
public String encodeURL(CharSequence url) {
    Args.notNull(url, ""url"");
        UrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();
    Url relativeUrl = Url.parse(url);
    String fullUrl = urlRenderer.renderFullUrl(relativeUrl);
    String encodedFullUrl = httpServletResponse.encodeURL(fullUrl);
    final String encodedRelativeUrl;
    if (fullUrl.equals(encodedFullUrl)) {
                encodedRelativeUrl = url.toString();
    } else {
                Url _encoded = Url.parse(encodedFullUrl);
        encodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);
    }
    return encodedRelativeUrl;
}",1.6666666666666667,0.30660377358490576,0.0,0.0,1.0,0.0,-1.0623756582796955,2.3333333333333335,-0.4,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5698_f45ce896,1.0,"@Override
public void unmount(String path) {
    final Url url = Url.parse(path);
    final Request request = createRequest(url);
    for (IRequestMapper mapper : this) {
        if (mapper.mapRequest(request) != null) {
            remove(mapper);
        }
    }
}","/**
 * {@inheritDoc}
 */
","@Override
public void unmount(String path) {
    final Url url = Url.parse(path);
    final Request request = createRequest(url);
    for (IRequestMapper mapper : this) {
        if (mapper.mapRequest(request) != null) {
            remove(mapper);
        }
    }
}",0.6666666666666666,1.55188679245283,0.5,1.0,1.0,0.9517241379310344,-0.4959625511995316,0.3333333333333333,0.18749999999999997,1.0258538941868995
wicket,remotes/origin/bugs-dot-jar_WICKET-5724_b92591f6,1.0,"@Override
public Component newComponent(ComponentTag tag) {
    String attributeName = getInlineEnclosureAttributeName(null);
    String childId = tag.getAttribute(attributeName);
    return new InlineEnclosure(tag.getId(), childId);
}","/**
 * {@inheritDoc}
 */
","@Override
public Component newComponent(ComponentTag tag) {
    String attributeName = getInlineEnclosureAttributeName(null);
    String childId = tag.getAttribute(attributeName);
    return new InlineEnclosure(tag.getId(), childId);
}",0.0,-0.11792452830188677,-0.5,-1.0,0.0,0.0,-0.028320655354008364,0.0,0.17500000000000004,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5783_7b8b6767,1.0,"@Override
protected void updateAjaxAttributes(AjaxRequestAttributes attributes) {
    super.updateAjaxAttributes(attributes);
    attributes.setEventNames(event);
}","/**
 * {@inheritDoc}
 */
","@Override
protected void updateAjaxAttributes(AjaxRequestAttributes attributes) {
    super.updateAjaxAttributes(attributes);
    attributes.setEventNames(event);
}",-0.16666666666666666,-0.15566037735849056,-0.5,-1.0,0.0,0.0,0.37097717963721444,-0.3333333333333333,-0.17500000000000004,0.0
wicket,remotes/origin/bugs-dot-jar_WICKET-5853_b80f6640,3.0,"/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)
 */
@Override
public Double convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.doubleValue();
}","/**
 *  @see org.apache.wicket.util.convert.IConverter#convertToObject(String, java.util.Locale)
 */
","@Override
public Double convertToObject(final String value, final Locale locale) {
    final Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);
    if (number == null) {
        return null;
    }
    return number.doubleValue();
}",0.3333333333333333,0.4952830188679243,0.0,0.0,0.6666666666666666,1.0827586206896553,-0.3110590988882384,-0.3333333333333333,-0.275,1.1492369075522
wicket,remotes/origin/bugs-dot-jar_WICKET-5916_def03add,1.0,"/**
 *  @see java.lang.Object#toString()
 */
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(super.toString());
    sb.append("":attached="").append(attached).append("":tempModelObject=["").append(this.transientModelObject).append(""]"");
    return sb.toString();
}","/**
 *  @see java.lang.Object#toString()
 */
","@Override
public String toString() {
    StringBuilder sb = new StringBuilder(super.toString());
    sb.append("":attached="").append(attached).append("":tempModelObject=["").append(this.transientModelObject).append(""]"");
    return sb.toString();
}",0.0,-0.11792452830188677,-0.5,-1.0,0.0,0.0,-0.02644821533060257,1.3333333333333333,0.2750000000000001,0.0
